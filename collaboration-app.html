<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaboration Board - Figma-like Real-time Tool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,400;9..40,500;9..40,600;9..40,700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ETHEREAL STUDIO - A warm, sophisticated design system
           Inspired by premium design tools with a human touch
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        :root {
            /* Warm Canvas */
            --canvas: #F5F3F0;
            --canvas-grid: rgba(0, 0, 0, 0.04);

            /* Glass Panels - Deep charcoal with warmth */
            --glass: rgba(28, 25, 23, 0.92);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-hover: rgba(255, 255, 255, 0.04);
            --glass-elevated: rgba(38, 35, 33, 0.95);

            /* Accent - Warm Coral */
            --accent: #E07A5F;
            --accent-soft: rgba(224, 122, 95, 0.15);
            --accent-glow: rgba(224, 122, 95, 0.3);

            /* Secondary - Sage Green */
            --sage: #81B29A;
            --sage-soft: rgba(129, 178, 154, 0.15);

            /* Semantic */
            --success: #81B29A;
            --warning: #F2CC8F;
            --error: #E07A5F;

            /* Text - Warm neutrals */
            --text-bright: #FEFDFB;
            --text-primary: #E8E4DF;
            --text-secondary: #A39E97;
            --text-muted: #6B6660;

            /* Shadows - Soft, floating */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.12);
            --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.16), 0 2px 8px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.1);
            --shadow-glow: 0 0 40px rgba(224, 122, 95, 0.15);

            /* Radii */
            --r-sm: 8px;
            --r-md: 12px;
            --r-lg: 16px;
            --r-xl: 20px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--canvas);
            overflow: hidden;
            color: var(--text-primary);
            font-size: 13px;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CANVAS - The infinite workspace
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background:
                radial-gradient(circle at 50% 0%, rgba(224, 122, 95, 0.03) 0%, transparent 50%),
                linear-gradient(90deg, var(--canvas-grid) 1px, transparent 1px) 0 0 / 24px 24px,
                linear-gradient(var(--canvas-grid) 1px, transparent 1px) 0 0 / 24px 24px,
                var(--canvas);
        }

        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            background: transparent;
            z-index: 1;
        }

        #selection-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }

        #cursor-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 100;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           REMOTE CURSORS - Collaborative presence
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .remote-cursor {
            position: absolute;
            pointer-events: none;
            transition: left 0.1s cubic-bezier(0.22, 1, 0.36, 1),
                        top 0.1s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .cursor-pointer {
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-bottom: 16px solid var(--cursor-color, var(--accent));
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        .cursor-label {
            position: absolute;
            left: 16px;
            top: 10px;
            background: var(--cursor-color, var(--accent));
            color: #fff;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: var(--shadow-sm);
            letter-spacing: 0.2px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TOOLBAR - Floating command center
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass);
            backdrop-filter: blur(20px) saturate(1.2);
            -webkit-backdrop-filter: blur(20px) saturate(1.2);
            padding: 6px 8px;
            border-radius: var(--r-xl);
            border: 1px solid var(--glass-border);
            display: flex;
            gap: 4px;
            align-items: center;
            z-index: 1000;
            box-shadow: var(--shadow-lg), inset 0 1px 0 rgba(255,255,255,0.05);
            animation: toolbar-appear 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }

        @keyframes toolbar-appear {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-12px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .tool-group {
            display: flex;
            gap: 2px;
            padding: 0 6px;
            position: relative;
        }

        .tool-group::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 24px;
            background: var(--glass-border);
        }

        .tool-group:last-child::after {
            display: none;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: var(--r-md);
            background: transparent;
            color: var(--text-secondary);
            font-size: 17px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.22, 1, 0.36, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .tool-btn:hover {
            background: var(--glass-hover);
            color: var(--text-bright);
            transform: translateY(-1px);
        }

        .tool-btn.active {
            background: var(--accent);
            color: #fff;
            box-shadow: 0 4px 12px var(--accent-glow);
        }

        .tool-btn.active:hover {
            transform: translateY(-1px);
        }

        .tool-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 1.75;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           COLOR PALETTE - Chromatic selection
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #color-palette {
            display: flex;
            gap: 4px;
            padding: 0 6px;
        }

        .color-btn {
            width: 22px;
            height: 22px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.22, 1, 0.36, 1);
            position: relative;
        }

        .color-btn:hover {
            transform: scale(1.15) translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .color-btn.active {
            border-color: var(--text-bright);
            transform: scale(1.1);
            box-shadow: 0 0 0 3px var(--glass), 0 4px 12px rgba(0,0,0,0.2);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BRUSH CONTROLS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #brush-size {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        #brush-size::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--accent-glow);
        }

        #brush-size::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 16px var(--accent-glow);
        }

        #brush-preview {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #brush-dot {
            background: var(--text-secondary);
            border-radius: 50%;
            transition: all 0.15s;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           PANELS - Floating glass cards
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .draggable-panel {
            position: fixed;
            background: var(--glass);
            backdrop-filter: blur(20px) saturate(1.2);
            -webkit-backdrop-filter: blur(20px) saturate(1.2);
            border-radius: var(--r-lg);
            border: 1px solid var(--glass-border);
            z-index: 1000;
            min-width: 220px;
            box-shadow: var(--shadow-lg), inset 0 1px 0 rgba(255,255,255,0.05);
            animation: panel-appear 0.4s cubic-bezier(0.22, 1, 0.36, 1) backwards;
        }

        #left-panel { animation-delay: 0.1s; }
        #right-panel { animation-delay: 0.2s; }
        #layer-panel { animation-delay: 0.3s; }

        @keyframes panel-appear {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            cursor: move;
            border-bottom: 1px solid var(--glass-border);
            user-select: none;
        }

        .panel-header h1, .panel-header h2, .panel-header h3 {
            margin: 0;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: var(--text-muted);
        }

        .panel-content {
            padding: 14px 16px;
        }

        .panel-content.collapsed {
            display: none;
        }

        .collapse-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            width: 24px;
            height: 24px;
            border-radius: var(--r-sm);
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .collapse-btn:hover {
            background: var(--glass-hover);
            color: var(--text-bright);
        }

        /* Left Panel - Board Info */
        #left-panel {
            top: 20px;
            left: 20px;
            min-width: 240px;
        }

        #left-panel h1 {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-bright);
            letter-spacing: -0.3px;
            text-transform: none;
        }

        .subtitle {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 16px;
            font-weight: 500;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--glass-border);
        }

        .status-row:last-child {
            border-bottom: none;
        }

        .status-label {
            color: var(--text-muted);
            font-size: 12px;
            font-weight: 500;
        }

        .status-value {
            color: var(--text-primary);
            font-family: 'Space Mono', monospace;
            font-size: 11px;
            font-weight: 400;
        }

        .status-value.connected {
            color: var(--success);
        }

        /* Right Panel - Users */
        #right-panel {
            top: 20px;
            right: 20px;
        }

        #right-panel .panel-content {
            max-height: 180px;
            overflow-y: auto;
        }

        .user-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: var(--r-md);
            transition: all 0.2s;
        }

        .user-item:hover {
            background: var(--glass-hover);
        }

        .user-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
            box-shadow: 0 0 8px currentColor;
        }

        .user-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Layer Panel */
        #layer-panel {
            right: 20px;
            top: 260px;
            width: 240px;
        }

        #layer-panel .panel-content {
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: transparent;
            border-radius: var(--r-md);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            border: 1px solid transparent;
        }

        .layer-item:hover {
            background: var(--glass-hover);
        }

        .layer-item.selected {
            background: var(--accent-soft);
            border-color: var(--accent);
        }

        .layer-item.locked {
            opacity: 0.4;
        }

        .layer-icon {
            font-size: 15px;
            width: 22px;
            text-align: center;
        }

        .layer-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
        }

        .layer-actions {
            display: flex;
            gap: 6px;
            padding: 10px;
            border-top: 1px solid var(--glass-border);
        }

        .layer-btn {
            flex: 1;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border: none;
            border-radius: var(--r-sm);
            cursor: pointer;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .layer-btn:hover {
            background: var(--glass-hover);
            color: var(--text-bright);
            transform: translateY(-1px);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CONNECT AREA - Bottom controls
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #connect-area {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            animation: connect-appear 0.5s cubic-bezier(0.22, 1, 0.36, 1) 0.4s backwards;
        }

        @keyframes connect-appear {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(12px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        #account-select {
            padding: 12px 18px;
            border-radius: var(--r-lg);
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
            font-size: 12px;
            font-family: 'Space Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: var(--shadow-md);
        }

        #account-select:hover {
            border-color: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }

        #account-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: var(--shadow-md), 0 0 0 3px var(--accent-soft);
        }

        .pk-input {
            padding: 12px 18px;
            border-radius: var(--r-lg);
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
            font-size: 12px;
            font-family: 'Space Mono', monospace;
            width: 300px;
            display: none;
            box-shadow: var(--shadow-md);
            transition: all 0.2s;
        }

        .pk-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: var(--shadow-md), 0 0 0 3px var(--accent-soft);
        }

        .pk-input::placeholder {
            color: var(--text-muted);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BUTTONS - Refined interactions
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .btn {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 13px;
            font-weight: 600;
            font-family: 'DM Sans', sans-serif;
            border-radius: var(--r-lg);
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.22, 1, 0.36, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-md), 0 4px 16px var(--accent-glow);
            letter-spacing: 0.2px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg), 0 8px 24px var(--accent-glow);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: rgba(255,255,255,0.08);
            color: var(--text-muted);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.secondary {
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-md);
        }

        .btn.secondary:hover {
            background: var(--glass-elevated);
            border-color: rgba(255,255,255,0.12);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MODALS - Centered dialogs
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--glass-elevated);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            padding: 32px;
            border-radius: var(--r-xl);
            border: 1px solid var(--glass-border);
            max-width: 460px;
            width: 90%;
            box-shadow: var(--shadow-lg), inset 0 1px 0 rgba(255,255,255,0.05);
            animation: modal-appear 0.3s cubic-bezier(0.22, 1, 0.36, 1);
        }

        @keyframes modal-appear {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .modal h2 {
            margin-bottom: 24px;
            font-size: 20px;
            font-weight: 700;
            color: var(--text-bright);
            letter-spacing: -0.3px;
        }

        .modal p {
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .modal input, .modal select {
            width: 100%;
            padding: 14px 16px;
            border-radius: var(--r-md);
            border: 1px solid var(--glass-border);
            background: rgba(0,0,0,0.2);
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            margin-bottom: 14px;
            transition: all 0.2s;
        }

        .modal input:focus, .modal select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-soft);
        }

        .modal input::placeholder {
            color: var(--text-muted);
        }

        .modal .btn-group {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 10px;
        }

        .modal-wide {
            min-width: 480px;
        }

        .board-list {
            max-height: 220px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .board-list-loading {
            color: var(--text-muted);
            padding: 32px;
            text-align: center;
            font-weight: 500;
        }

        .board-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: var(--r-md);
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .board-item:hover {
            background: rgba(255,255,255,0.06);
            border-color: var(--glass-border);
            transform: translateX(4px);
        }

        .board-item-name {
            font-weight: 600;
            color: var(--text-bright);
            font-size: 14px;
        }

        .board-item-meta {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .modal-section {
            border-top: 1px solid var(--glass-border);
            padding-top: 20px;
            margin-top: 16px;
        }

        .modal-section-title {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .create-board-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .create-board-row input {
            flex: 1;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 8px 0;
        }

        .checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .modal details {
            margin-top: 20px;
        }

        .modal details summary {
            color: var(--text-muted);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: color 0.2s;
        }

        .modal details summary:hover {
            color: var(--text-secondary);
        }

        .modal details[open] summary {
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        .modal-footer {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--glass-border);
            text-align: center;
        }

        .btn-small {
            font-size: 12px;
            padding: 8px 14px;
        }

        .board-badge {
            font-size: 10px;
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 600;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .badge-success {
            color: var(--success);
            background: var(--sage-soft);
        }

        .badge-warning {
            color: #C9A227;
            background: rgba(242, 204, 143, 0.15);
        }

        .board-list-error {
            color: var(--error);
            padding: 32px;
            text-align: center;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           EVENT LOG - Developer console
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #event-log {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 12px 14px;
            border-radius: var(--r-md);
            border: 1px solid var(--glass-border);
            width: 280px;
            max-height: 140px;
            overflow-y: auto;
            font-family: 'Space Mono', monospace;
            font-size: 10px;
            z-index: 1000;
            box-shadow: var(--shadow-md);
            animation: panel-appear 0.4s cubic-bezier(0.22, 1, 0.36, 1) 0.5s backwards;
        }

        .log-entry {
            color: var(--text-muted);
            margin-bottom: 5px;
            line-height: 1.5;
            padding: 2px 0;
        }

        .log-entry.tx { color: var(--success); }
        .log-entry.event { color: var(--accent); }
        .log-entry.error { color: var(--error); }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SPINNER
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TEXT INPUT OVERLAY
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #text-input-overlay {
            display: none;
            position: fixed;
            z-index: 1500;
        }

        #text-input-overlay.active {
            display: block;
        }

        #text-input-overlay input {
            padding: 12px 16px;
            font-size: 15px;
            font-family: 'DM Sans', sans-serif;
            border: 2px solid var(--accent);
            border-radius: var(--r-md);
            background: #fff;
            color: #1a1a1a;
            min-width: 200px;
            box-shadow: var(--shadow-lg), 0 0 0 4px var(--accent-soft);
        }

        #text-input-overlay input:focus {
            outline: none;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STICKY NOTE EDITOR
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .sticky-editor {
            position: fixed;
            z-index: 2000;
        }

        .sticky-editor-container {
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
            border-radius: var(--r-md);
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .sticky-color-picker {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: rgba(0,0,0,0.05);
        }

        .sticky-color-opt {
            width: 24px;
            height: 24px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sticky-color-opt:hover {
            transform: scale(1.1);
        }

        .sticky-color-opt.active {
            border-color: rgba(0,0,0,0.3);
            box-shadow: 0 0 0 2px #fff, 0 2px 8px rgba(0,0,0,0.15);
        }

        .sticky-textarea {
            flex: 1;
            border: none;
            background: transparent;
            padding: 14px;
            font-size: 15px;
            resize: none;
            outline: none;
            font-family: 'DM Sans', sans-serif;
            line-height: 1.5;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           NICKNAME MODAL
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .nickname-preview {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: rgba(0,0,0,0.15);
            border-radius: var(--r-md);
            margin-top: 16px;
        }

        .preview-label {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .preview-cursor {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-cursor-icon {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 14px solid var(--accent);
            transform: rotate(-45deg);
        }

        .preview-cursor-name {
            background: var(--accent);
            color: #fff;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.2px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CUSTOM SCROLLBARS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.15);
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
        <canvas id="selection-canvas"></canvas>
        <div id="cursor-layer"></div>
    </div>

    <!-- ìƒë‹¨ íˆ´ë°” -->
    <div id="toolbar">
        <div class="tool-group">
            <button class="tool-btn" data-tool="select" title="Select (V)">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
            </button>
        </div>
        <div class="tool-group">
            <button class="tool-btn active" data-tool="pen" title="Pen (P)">âœï¸</button>
            <button class="tool-btn" data-tool="eraser" title="Eraser (E)">ğŸ§½</button>
        </div>
        <div class="tool-group">
            <button class="tool-btn" data-tool="rect" title="Rectangle (R)">â¬œ</button>
            <button class="tool-btn" data-tool="ellipse" title="Ellipse (O)">â­•</button>
            <button class="tool-btn" data-tool="line" title="Line (L)">ğŸ“</button>
            <button class="tool-btn" data-tool="arrow" title="Arrow (A)">â¡ï¸</button>
        </div>
        <div class="tool-group">
            <button class="tool-btn" data-tool="sticky" title="Sticky Note (S)">ğŸ“</button>
            <button class="tool-btn" data-tool="text" title="Text (T)">T</button>
        </div>
        <div class="tool-group" id="color-palette"></div>
        <div class="tool-group">
            <input type="range" id="brush-size" min="1" max="20" value="3">
            <div id="brush-preview"><div id="brush-dot"></div></div>
        </div>
        <div class="tool-group">
            <button class="tool-btn" id="clear-btn" title="Clear Canvas">ğŸ—‘ï¸</button>
        </div>
    </div>

    <!-- ì¢Œì¸¡ ìƒíƒœ íŒ¨ë„ -->
    <div id="left-panel" class="draggable-panel">
        <div class="panel-header" data-panel="left-panel">
            <h1>Collaboration Board</h1>
            <button class="collapse-btn" data-target="left-content">âˆ’</button>
        </div>
        <div class="panel-content" id="left-content">
            <div class="subtitle">Figma-like tool on blockchain</div>
            <div class="status-row">
                <span class="status-label">Status</span>
                <span class="status-value" id="connection-status">Not Connected</span>
            </div>
            <div class="status-row">
                <span class="status-label">Address</span>
                <span class="status-value" id="my-address">-</span>
            </div>
            <div class="status-row">
                <span class="status-label">Objects</span>
                <span class="status-value" id="object-count">0</span>
            </div>
            <div class="status-row">
                <span class="status-label">TX Sent</span>
                <span class="status-value" id="tx-sent">0</span>
            </div>
        </div>
    </div>

    <!-- ìš°ì¸¡ ìœ ì € íŒ¨ë„ -->
    <div id="right-panel" class="draggable-panel">
        <div class="panel-header" data-panel="right-panel">
            <h2>Online (<span id="user-count">0</span>)</h2>
            <button class="collapse-btn" data-target="right-content">âˆ’</button>
        </div>
        <div class="panel-content" id="right-content">
            <div id="users"></div>
        </div>
    </div>

    <!-- ë ˆì´ì–´ íŒ¨ë„ -->
    <div id="layer-panel" class="draggable-panel">
        <div class="panel-header" data-panel="layer-panel">
            <h3>Layers</h3>
            <button class="collapse-btn" data-target="layer-content">âˆ’</button>
        </div>
        <div class="panel-content" id="layer-content">
            <div class="layer-list" id="layer-list"></div>
            <div class="layer-actions">
                <button class="layer-btn" id="bring-front-btn" title="Bring to Front">â¬†ï¸</button>
                <button class="layer-btn" id="send-back-btn" title="Send to Back">â¬‡ï¸</button>
                <button class="layer-btn" id="lock-btn" title="Lock">ğŸ”’</button>
                <button class="layer-btn" id="delete-btn" title="Delete">ğŸ—‘ï¸</button>
            </div>
        </div>
    </div>

    <!-- ì´ë²¤íŠ¸ ë¡œê·¸ -->
    <div id="event-log"></div>

    <!-- ì—°ê²° ë²„íŠ¼ -->
    <div id="connect-area">
        <select id="account-select">
            <option value="0">Anvil #0 (0xf39F...2266)</option>
            <option value="1">Anvil #1 (0x7099...79C8)</option>
            <option value="2">Anvil #2 (0x3C44...93fC)</option>
            <option value="3">Anvil #3 (0x90F7...4485)</option>
            <option value="4">Anvil #4 (0x15d3...2b28)</option>
            <option value="custom">Custom Key...</option>
        </select>
        <input type="text" id="pk-input" placeholder="Enter Private Key (0x...)" class="pk-input">
        <button class="btn" id="connect-btn">Connect</button>
        <button class="btn secondary" id="disconnect-btn" style="display:none;">Disconnect</button>
        <button class="btn secondary" id="deploy-btn" disabled>Setup Contract</button>
        <button class="btn secondary" id="join-btn" disabled>Join Room</button>
    </div>

    <!-- ë³´ë“œ ì„ íƒ ëª¨ë‹¬ -->
    <div class="modal" id="contract-modal">
        <div class="modal-content modal-wide">
            <h2>Select Whiteboard</h2>

            <!-- ë³´ë“œ ëª©ë¡ -->
            <div id="board-list" class="board-list">
                <div class="board-list-loading">Loading boards...</div>
            </div>

            <!-- ìƒˆ ë³´ë“œ ë§Œë“¤ê¸° -->
            <div class="modal-section">
                <p class="modal-section-title">Or create a new board:</p>
                <div class="create-board-row">
                    <input type="text" id="new-board-name" placeholder="Board name">
                    <button class="btn" id="create-board-btn">Create</button>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="allow-anyone-delete">
                    Allow anyone to delete (uncheck for owner-only)
                </label>
            </div>

            <!-- ìˆ˜ë™ ì…ë ¥ (ì ‘ê¸°) -->
            <details>
                <summary>Manual address entry</summary>
                <div>
                    <input type="text" id="contract-input" placeholder="0x... (contract address)">
                    <button class="btn secondary" id="use-existing-btn" style="margin-top:8px;width:100%;">Connect</button>
                </div>
            </details>

            <!-- Registry ë³€ê²½ -->
            <div class="modal-footer">
                <button class="btn secondary btn-small" id="change-registry-btn">Change Registry Address</button>
            </div>
        </div>
    </div>

    <!-- ë‹‰ë„¤ì„ ì…ë ¥ ëª¨ë‹¬ -->
    <div class="modal" id="nickname-modal">
        <div class="modal-content" style="max-width: 380px;">
            <h2>Enter Your Nickname</h2>
            <p style="margin-bottom: 20px;">Choose a name that other collaborators will see.</p>
            <input type="text" id="nickname-input" placeholder="Your nickname..." maxlength="20" autofocus>
            <div class="nickname-preview">
                <span class="preview-label">Preview:</span>
                <div class="preview-cursor">
                    <div class="preview-cursor-icon"></div>
                    <span class="preview-cursor-name" id="nickname-preview-text">Designer</span>
                </div>
            </div>
            <div class="btn-group" style="margin-top: 20px;">
                <button class="btn secondary" id="nickname-cancel-btn">Cancel</button>
                <button class="btn" id="nickname-confirm-btn">Join Board</button>
            </div>
        </div>
    </div>

    <!-- í…ìŠ¤íŠ¸ ì…ë ¥ -->
    <div id="text-input-overlay">
        <input type="text" id="text-input" placeholder="Type here...">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script>
        // ===== ì„¤ì • =====
        const CONFIG = {
            // ë¡œì»¬ í…ŒìŠ¤íŠ¸ìš© (Anvil)
            chainId: 31337,
            chainName: 'Anvil Local',
            rpcUrl: 'http://localhost:8545',
            // ì‹¤ì œ ë°°í¬ì‹œ:
            // chainId: 85300,
            // chainName: 'CipherBFT L1',
            // rpcUrl: 'https://rpc.cipherbft.xyz/',

            colors: [
                '#000000', '#ffffff', '#ff0000', '#ff9900',
                '#ffff00', '#00ff00', '#00ffff', '#0000ff',
                '#9900ff', '#ff00ff', '#795548', '#607d8b',
                '#e91e63', '#00bcd4', '#8bc34a', '#ff5722'
            ],

            stickyColors: [
                '#fff740', '#ff7eb9', '#7afcff',
                '#98ff98', '#ffb366', '#e0b0ff'
            ],

            objectTypes: ['stroke', 'rectangle', 'ellipse', 'line', 'arrow', 'stickyNote', 'text']
        };

        const CONTRACT_ABI = [
            // User management
            "function join(string nickname) external",
            "function leave() external",
            "function updateNickname(string newNickname) external",
            "function getActiveUsers() view returns (address[])",
            "function getUserInfo(address user) view returns (string nickname, bool isActive, uint256 objectCount)",

            // Object creation
            "function createStroke(int16[] points, uint8 colorIndex, uint8 strokeWidth) external returns (uint256)",
            "function createShape(uint8 shapeType, int32 x, int32 y, uint16 width, uint16 height, uint16 rotation, uint8 colorIndex, uint8 strokeWidth) external returns (uint256)",
            "function createStickyNote(int32 x, int32 y, uint16 width, uint16 height, string content, uint8 bgColorIndex) external returns (uint256)",
            "function createText(int32 x, int32 y, string content, uint8 colorIndex, uint8 fontSize) external returns (uint256)",

            // Transformations
            "function moveObject(uint256 objectId, int32 newX, int32 newY) external",
            "function resizeObject(uint256 objectId, uint16 newWidth, uint16 newHeight) external",
            "function deleteObject(uint256 objectId) external",

            // Layer management
            "function bringToFront(uint256 objectId) external",
            "function sendToBack(uint256 objectId) external",

            // Content updates
            "function updateStickyNote(uint256 objectId, string newContent) external",
            "function updateText(uint256 objectId, string newContent) external",

            // Lock
            "function toggleLock(uint256 objectId) external",

            // Canvas
            "function clearCanvas() external",

            // Cursor
            "function moveCursor(int32 x, int32 y) external",

            // View
            "function totalObjects() view returns (uint256)",
            "function canvasVersion() view returns (uint256)",
            "function getObjectInfo(uint256 objectId) view returns (address creator, uint8 objectType, uint8 colorIndex, uint8 strokeWidth, uint16 layer, bool isLocked, bool isDeleted)",

            // Events
            "event ObjectCreated(address indexed creator, uint256 indexed objectId, uint8 objectType, uint8 colorIndex, uint8 strokeWidth, uint16 layer)",
            "event StrokePoints(uint256 indexed objectId, int16[] points)",
            "event ShapeGeometry(uint256 indexed objectId, int32 x, int32 y, uint16 width, uint16 height, uint16 rotation)",
            "event StickyNoteData(uint256 indexed objectId, int32 x, int32 y, uint16 width, uint16 height, string content, uint8 bgColorIndex)",
            "event TextData(uint256 indexed objectId, int32 x, int32 y, string content, uint8 fontSize)",
            "event ObjectMoved(address indexed user, uint256 indexed objectId, int32 newX, int32 newY)",
            "event ObjectResized(address indexed user, uint256 indexed objectId, uint16 newWidth, uint16 newHeight)",
            "event ObjectDeleted(address indexed user, uint256 indexed objectId)",
            "event LayerChanged(uint256 indexed objectId, uint16 oldLayer, uint16 newLayer)",
            "event ContentUpdated(uint256 indexed objectId, string newContent)",
            "event ObjectLockToggled(uint256 indexed objectId, bool isLocked)",
            "event UserJoined(address indexed user, string nickname)",
            "event UserLeft(address indexed user)",
            "event NicknameUpdated(address indexed user, string newNickname)",
            "event CanvasCleared(address indexed user)",
            "event CursorMoved(address indexed user, int32 x, int32 y)"
        ];

        const REGISTRY_ABI = [
            "function createBoard(string name, bool allowAnyoneDelete) external returns (uint256 boardId, address boardAddress)",
            "function getBoardCount() view returns (uint256)",
            "function getBoard(uint256 boardId) view returns (address boardAddress, string name, address creator, uint256 createdAt, bool allowAnyoneDelete)",
            "function getAllBoards() view returns (tuple(address boardAddress, string name, address creator, uint256 createdAt, bool allowAnyoneDelete)[])",
            "function getUserBoards(address user) view returns (uint256[])",
            "event BoardCreated(uint256 indexed boardId, address indexed boardAddress, string name, address indexed creator, bool allowAnyoneDelete)"
        ];

        // BoardRegistry ì£¼ì†Œ (ë°°í¬ í›„ ì—…ë°ì´íŠ¸ í•„ìš”)
        let registryAddress = localStorage.getItem('boardRegistryAddress') || '';
        let registryContract = null;

        // ===== ObjectManager =====
        class ObjectManager {
            constructor() {
                this.objects = new Map();
                this.layerOrder = [];
                this.deletedObjects = new Set();
                this.nextLocalId = -1; // ë¡œì»¬ ì„ì‹œ IDëŠ” ìŒìˆ˜
            }

            addObject(objData) {
                this.objects.set(objData.id, objData);
                this._updateLayerOrder();
                return objData;
            }

            updateObject(objectId, updates) {
                const obj = this.objects.get(objectId);
                if (obj && !this.deletedObjects.has(objectId)) {
                    Object.assign(obj, updates);
                    if ('layer' in updates) {
                        this._updateLayerOrder();
                    }
                }
            }

            deleteObject(objectId) {
                this.deletedObjects.add(objectId);
                this._updateLayerOrder();
            }

            getObject(objectId) {
                if (this.deletedObjects.has(objectId)) return null;
                return this.objects.get(objectId);
            }

            getObjectsInLayerOrder() {
                return this.layerOrder
                    .filter(id => !this.deletedObjects.has(id))
                    .map(id => this.objects.get(id));
            }

            getObjectAtPoint(x, y) {
                const sorted = [...this.layerOrder].reverse();
                for (const id of sorted) {
                    if (this.deletedObjects.has(id)) continue;
                    const obj = this.objects.get(id);
                    if (obj && this._pointInBounds(x, y, obj)) {
                        return obj;
                    }
                }
                return null;
            }

            _pointInBounds(x, y, obj) {
                if (!obj.bounds) return false;
                const b = obj.bounds;
                const pad = (obj.strokeWidth || 5) + 5;
                return x >= b.x - pad && x <= b.x + b.width + pad &&
                       y >= b.y - pad && y <= b.y + b.height + pad;
            }

            _updateLayerOrder() {
                this.layerOrder = [...this.objects.keys()]
                    .filter(id => !this.deletedObjects.has(id))
                    .sort((a, b) => {
                        const objA = this.objects.get(a);
                        const objB = this.objects.get(b);
                        return (objA?.layer || 0) - (objB?.layer || 0);
                    });
            }

            calculateStrokeBounds(points) {
                if (!points || points.length < 2) return { x: 0, y: 0, width: 0, height: 0 };
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                for (let i = 0; i < points.length; i += 2) {
                    const px = points[i];
                    const py = points[i + 1];
                    minX = Math.min(minX, px);
                    maxX = Math.max(maxX, px);
                    minY = Math.min(minY, py);
                    maxY = Math.max(maxY, py);
                }

                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX || 1,
                    height: maxY - minY || 1
                };
            }

            generateLocalId() {
                return this.nextLocalId--;
            }

            clear() {
                this.objects.clear();
                this.layerOrder = [];
                this.deletedObjects.clear();
            }
        }

        // ===== SelectionSystem =====
        class SelectionSystem {
            constructor(objectManager) {
                this.objectManager = objectManager;
                this.selectedIds = new Set();
                this.selectionBounds = null;
                this.transformMode = null;
                this.dragStart = null;
                this.originalBounds = null;
                this.originalObjectBounds = new Map();
                this.originalObjectPoints = new Map(); // ìŠ¤íŠ¸ë¡œí¬ìš© ì›ë³¸ í¬ì¸íŠ¸
                this.handleSize = 10;
            }

            selectObject(objectId, addToSelection = false) {
                if (!addToSelection) {
                    this.selectedIds.clear();
                }
                this.selectedIds.add(objectId);
                this._updateSelectionBounds();
            }

            deselectAll() {
                this.selectedIds.clear();
                this.selectionBounds = null;
            }

            getSelectedObjects() {
                return [...this.selectedIds]
                    .map(id => this.objectManager.getObject(id))
                    .filter(Boolean);
            }

            hasSelection() {
                return this.selectedIds.size > 0;
            }

            _updateSelectionBounds() {
                if (this.selectedIds.size === 0) {
                    this.selectionBounds = null;
                    return;
                }

                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                for (const id of this.selectedIds) {
                    const obj = this.objectManager.getObject(id);
                    if (obj && obj.bounds) {
                        minX = Math.min(minX, obj.bounds.x);
                        minY = Math.min(minY, obj.bounds.y);
                        maxX = Math.max(maxX, obj.bounds.x + obj.bounds.width);
                        maxY = Math.max(maxY, obj.bounds.y + obj.bounds.height);
                    }
                }

                if (minX !== Infinity) {
                    this.selectionBounds = {
                        x: minX,
                        y: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                }
            }

            getHandlePositions() {
                if (!this.selectionBounds) return {};
                const b = this.selectionBounds;
                return {
                    nw: { x: b.x, y: b.y },
                    n:  { x: b.x + b.width / 2, y: b.y },
                    ne: { x: b.x + b.width, y: b.y },
                    e:  { x: b.x + b.width, y: b.y + b.height / 2 },
                    se: { x: b.x + b.width, y: b.y + b.height },
                    s:  { x: b.x + b.width / 2, y: b.y + b.height },
                    sw: { x: b.x, y: b.y + b.height },
                    w:  { x: b.x, y: b.y + b.height / 2 }
                };
            }

            getHandleAtPoint(x, y) {
                if (!this.selectionBounds) return null;
                const positions = this.getHandlePositions();
                for (const [name, pos] of Object.entries(positions)) {
                    if (Math.abs(x - pos.x) <= this.handleSize &&
                        Math.abs(y - pos.y) <= this.handleSize) {
                        return name;
                    }
                }
                return null;
            }

            isPointInSelection(x, y) {
                if (!this.selectionBounds) return false;
                const b = this.selectionBounds;
                return x >= b.x && x <= b.x + b.width &&
                       y >= b.y && y <= b.y + b.height;
            }

            startTransform(mode, startPoint) {
                this.transformMode = mode;
                this.dragStart = { ...startPoint };
                this.originalBounds = this.selectionBounds ? { ...this.selectionBounds } : null;
                this.originalObjectBounds = new Map();
                this.originalObjectPoints = new Map();

                for (const id of this.selectedIds) {
                    const obj = this.objectManager.getObject(id);
                    if (!obj) continue;

                    // boundsê°€ ì—†ìœ¼ë©´ ê³„ì‚°
                    if (!obj.bounds) {
                        if (obj.type === 'stroke' && obj.points && obj.points.length >= 2) {
                            obj.bounds = this.objectManager.calculateStrokeBounds(obj.points);
                        } else {
                            continue;
                        }
                    }

                    this.originalObjectBounds.set(id, { ...obj.bounds });

                    // ìŠ¤íŠ¸ë¡œí¬ì˜ ê²½ìš° ì›ë³¸ í¬ì¸íŠ¸ë„ ì €ì¥
                    if (obj.type === 'stroke' && obj.points) {
                        this.originalObjectPoints.set(id, [...obj.points]);
                    }
                }
            }

            updateTransform(currentPoint) {
                if (!this.transformMode || !this.dragStart) return;

                const dx = currentPoint.x - this.dragStart.x;
                const dy = currentPoint.y - this.dragStart.y;

                if (this.transformMode === 'move') {
                    for (const id of this.selectedIds) {
                        let original = this.originalObjectBounds.get(id);
                        const obj = this.objectManager.getObject(id);

                        if (!obj) continue;

                        // boundsê°€ ì—†ìœ¼ë©´ ì„¤ì •
                        if (!original) {
                            if (obj.bounds) {
                                original = { ...obj.bounds };
                            } else if (obj.points && obj.points.length >= 2) {
                                const calculatedBounds = this.objectManager.calculateStrokeBounds(obj.points);
                                obj.bounds = calculatedBounds;
                                original = { ...calculatedBounds };
                            } else {
                                continue;
                            }
                            this.originalObjectBounds.set(id, original);

                            // ìŠ¤íŠ¸ë¡œí¬ì¸ë° ì›ë³¸ í¬ì¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì €ì¥
                            if (obj.type === 'stroke' && obj.points && !this.originalObjectPoints.has(id)) {
                                this.originalObjectPoints.set(id, [...obj.points]);
                            }
                        }

                        const updates = {
                            bounds: {
                                x: original.x + dx,
                                y: original.y + dy,
                                width: original.width,
                                height: original.height
                            }
                        };

                        // ìŠ¤íŠ¸ë¡œí¬ì˜ ê²½ìš° í¬ì¸íŠ¸ë„ ë³€í™˜
                        if (obj.type === 'stroke') {
                            const originalPoints = this.originalObjectPoints.get(id);
                            if (originalPoints) {
                                const newPoints = [];
                                for (let i = 0; i < originalPoints.length; i += 2) {
                                    newPoints.push(originalPoints[i] + dx);
                                    newPoints.push(originalPoints[i + 1] + dy);
                                }
                                updates.points = newPoints;
                            }
                        }

                        this.objectManager.updateObject(id, updates);
                    }
                } else if (this.transformMode.startsWith('resize')) {
                    this._handleResize(dx, dy);
                }

                this._updateSelectionBounds();
            }

            _handleResize(dx, dy) {
                const mode = this.transformMode.replace('resize-', '');
                const ob = this.originalBounds;
                if (!ob) return;

                let scaleX = 1, scaleY = 1;
                let offsetX = 0, offsetY = 0;

                if (mode.includes('e')) {
                    scaleX = Math.max(0.1, (ob.width + dx) / ob.width);
                }
                if (mode.includes('w')) {
                    scaleX = Math.max(0.1, (ob.width - dx) / ob.width);
                    offsetX = dx;
                }
                if (mode.includes('s')) {
                    scaleY = Math.max(0.1, (ob.height + dy) / ob.height);
                }
                if (mode.includes('n')) {
                    scaleY = Math.max(0.1, (ob.height - dy) / ob.height);
                    offsetY = dy;
                }

                for (const id of this.selectedIds) {
                    const original = this.originalObjectBounds.get(id);
                    if (original) {
                        const relX = ob.width > 0 ? (original.x - ob.x) / ob.width : 0;
                        const relY = ob.height > 0 ? (original.y - ob.y) / ob.height : 0;

                        const obj = this.objectManager.getObject(id);
                        const updates = {
                            bounds: {
                                x: ob.x + offsetX + relX * ob.width * scaleX,
                                y: ob.y + offsetY + relY * ob.height * scaleY,
                                width: Math.max(10, original.width * scaleX),
                                height: Math.max(10, original.height * scaleY)
                            }
                        };

                        // ìŠ¤íŠ¸ë¡œí¬ì˜ ê²½ìš° í¬ì¸íŠ¸ë„ ìŠ¤ì¼€ì¼ ë³€í™˜
                        if (obj && obj.type === 'stroke') {
                            const originalPoints = this.originalObjectPoints.get(id);
                            if (originalPoints && original) {
                                const newPoints = [];
                                for (let i = 0; i < originalPoints.length; i += 2) {
                                    // ì›ë˜ bounds ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ìœ„ì¹˜ ê³„ì‚°
                                    const relPx = original.width > 0 ? (originalPoints[i] - original.x) / original.width : 0;
                                    const relPy = original.height > 0 ? (originalPoints[i + 1] - original.y) / original.height : 0;
                                    // ìƒˆ bounds í¬ê¸°ì— ë§ê²Œ ë³€í™˜
                                    newPoints.push(updates.bounds.x + relPx * updates.bounds.width);
                                    newPoints.push(updates.bounds.y + relPy * updates.bounds.height);
                                }
                                updates.points = newPoints;
                            }
                        }

                        this.objectManager.updateObject(id, updates);
                    }
                }
            }

            endTransform() {
                const result = {
                    mode: this.transformMode,
                    objects: this.getSelectedObjects()
                };

                this.transformMode = null;
                this.dragStart = null;
                this.originalBounds = null;
                this.originalObjectBounds.clear();
                if (this.originalObjectPoints) {
                    this.originalObjectPoints.clear();
                }

                return result;
            }

            drawSelection(ctx) {
                if (!this.selectionBounds) return;

                const b = this.selectionBounds;

                // ì„ íƒ ë°•ìŠ¤
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(b.x, b.y, b.width, b.height);
                ctx.setLineDash([]);

                // í•¸ë“¤
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 1;

                const positions = this.getHandlePositions();
                for (const pos of Object.values(positions)) {
                    ctx.beginPath();
                    ctx.rect(
                        pos.x - this.handleSize / 2,
                        pos.y - this.handleSize / 2,
                        this.handleSize,
                        this.handleSize
                    );
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }

        // ===== CanvasRenderer =====
        class CanvasRenderer {
            constructor(canvas, objectManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.objectManager = objectManager;
            }

            render() {
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const objects = this.objectManager.getObjectsInLayerOrder();
                for (const obj of objects) {
                    this._renderObject(obj);
                }
            }

            _renderObject(obj) {
                if (!obj) return;
                const color = CONFIG.colors[obj.colorIndex] || '#000000';

                switch (obj.type) {
                    case 'stroke':
                        this._renderStroke(obj, color);
                        break;
                    case 'rectangle':
                        this._renderRectangle(obj, color);
                        break;
                    case 'ellipse':
                        this._renderEllipse(obj, color);
                        break;
                    case 'line':
                        this._renderLine(obj, color);
                        break;
                    case 'arrow':
                        this._renderArrow(obj, color);
                        break;
                    case 'stickyNote':
                        this._renderStickyNote(obj);
                        break;
                    case 'text':
                        this._renderText(obj, color);
                        break;
                }
            }

            _renderStroke(obj, color) {
                if (!obj.points || obj.points.length < 4) return;

                this.ctx.beginPath();
                this.ctx.moveTo(obj.points[0], obj.points[1]);

                for (let i = 2; i < obj.points.length; i += 2) {
                    this.ctx.lineTo(obj.points[i], obj.points[i + 1]);
                }

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = obj.strokeWidth || 3;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.stroke();
            }

            _renderRectangle(obj, color) {
                const b = obj.bounds;
                if (!b) return;

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = obj.strokeWidth || 2;
                this.ctx.strokeRect(b.x, b.y, b.width, b.height);
            }

            _renderEllipse(obj, color) {
                const b = obj.bounds;
                if (!b) return;

                const cx = b.x + b.width / 2;
                const cy = b.y + b.height / 2;

                this.ctx.beginPath();
                this.ctx.ellipse(cx, cy, b.width / 2, b.height / 2, 0, 0, Math.PI * 2);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = obj.strokeWidth || 2;
                this.ctx.stroke();
            }

            _renderLine(obj, color) {
                const b = obj.bounds;
                if (!b) return;

                this.ctx.beginPath();
                this.ctx.moveTo(b.x, b.y);
                this.ctx.lineTo(b.x + b.width, b.y + b.height);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = obj.strokeWidth || 2;
                this.ctx.stroke();
            }

            _renderArrow(obj, color) {
                const b = obj.bounds;
                if (!b) return;

                const x1 = b.x, y1 = b.y;
                const x2 = b.x + b.width, y2 = b.y + b.height;
                const headLen = 15;
                const angle = Math.atan2(b.height, b.width);

                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.lineTo(
                    x2 - headLen * Math.cos(angle - Math.PI / 6),
                    y2 - headLen * Math.sin(angle - Math.PI / 6)
                );
                this.ctx.moveTo(x2, y2);
                this.ctx.lineTo(
                    x2 - headLen * Math.cos(angle + Math.PI / 6),
                    y2 - headLen * Math.sin(angle + Math.PI / 6)
                );

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = obj.strokeWidth || 2;
                this.ctx.stroke();
            }

            _renderStickyNote(obj) {
                const b = obj.bounds;
                if (!b) return;

                const bgColor = CONFIG.stickyColors[obj.bgColorIndex || 0] || '#fff740';

                // ê·¸ë¦¼ì
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                this.ctx.shadowBlur = 10;
                this.ctx.shadowOffsetX = 3;
                this.ctx.shadowOffsetY = 3;

                // ë°°ê²½
                this.ctx.fillStyle = bgColor;
                this.ctx.fillRect(b.x, b.y, b.width, b.height);

                // ê·¸ë¦¼ì ë¦¬ì…‹
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;

                // ì ‘íŒ ëª¨ì„œë¦¬
                this.ctx.fillStyle = this._darkenColor(bgColor, 20);
                this.ctx.beginPath();
                this.ctx.moveTo(b.x + b.width - 20, b.y);
                this.ctx.lineTo(b.x + b.width, b.y + 20);
                this.ctx.lineTo(b.x + b.width, b.y);
                this.ctx.closePath();
                this.ctx.fill();

                // í…ìŠ¤íŠ¸
                if (obj.content) {
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '14px sans-serif';
                    this._wrapText(obj.content, b.x + 10, b.y + 25, b.width - 20, 20);
                } else {
                    this.ctx.fillStyle = '#999';
                    this.ctx.font = 'italic 14px sans-serif';
                    this.ctx.fillText('Double-click to edit', b.x + 10, b.y + 30);
                }
            }

            _renderText(obj, color) {
                const b = obj.bounds;
                if (!b) return;

                const fontSize = (obj.strokeWidth || 3) * 5;
                this.ctx.font = `${fontSize}px sans-serif`;
                this.ctx.fillStyle = color;
                this.ctx.fillText(obj.content || '', b.x, b.y + fontSize);
            }

            _wrapText(text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                let currentY = y;

                for (const word of words) {
                    const testLine = line + word + ' ';
                    const metrics = this.ctx.measureText(testLine);

                    if (metrics.width > maxWidth && line !== '') {
                        this.ctx.fillText(line, x, currentY);
                        line = word + ' ';
                        currentY += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                this.ctx.fillText(line, x, currentY);
            }

            _darkenColor(hex, percent) {
                const num = parseInt(hex.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max(0, (num >> 16) - amt);
                const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
                const B = Math.max(0, (num & 0x0000FF) - amt);
                return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
            }
        }

        // ===== ì „ì—­ ìƒíƒœ =====
        let provider = null;
        let signer = null;
        let contract = null;
        let contractAddress = null;
        let myAddress = null;
        let isJoined = false;
        let userNickname = null;

        let sessionWallet = null;
        let sessionContract = null;

        let mainCanvas, mainCtx, selectionCanvas, selectionCtx;
        let objectManager, selectionSystem, canvasRenderer;

        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentColorIndex = 0;
        let brushSize = 3;

        let isDrawing = false;
        let shapeStart = null;
        let strokePoints = [];
        let lastPoint = null;

        const cursors = new Map();
        let stats = { txSent: 0, objects: 0 };
        let pollingIntervalId = null;

        // í¸ì§‘ ì¤‘ì¸ ìŠ¤í‹°í‚¤ ë…¸íŠ¸
        let editingStickyId = null;

        // DOM ìš”ì†Œ
        const canvasContainer = document.getElementById('canvas-container');
        const cursorLayer = document.getElementById('cursor-layer');
        const eventLog = document.getElementById('event-log');
        const layerList = document.getElementById('layer-list');

        // ===== ì´ˆê¸°í™” =====
        function init() {
            // ìº”ë²„ìŠ¤ ì„¤ì •
            mainCanvas = document.getElementById('main-canvas');
            mainCtx = mainCanvas.getContext('2d');
            selectionCanvas = document.getElementById('selection-canvas');
            selectionCtx = selectionCanvas.getContext('2d');

            // ë§¤ë‹ˆì € ì´ˆê¸°í™” (resizeCanvasë³´ë‹¤ ë¨¼ì €!)
            objectManager = new ObjectManager();
            selectionSystem = new SelectionSystem(objectManager);
            canvasRenderer = new CanvasRenderer(mainCanvas, objectManager);

            resizeCanvas();

            // ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ìƒì„±
            const palette = document.getElementById('color-palette');
            CONFIG.colors.forEach((color, i) => {
                const btn = document.createElement('button');
                btn.className = 'color-btn' + (i === 0 ? ' active' : '');
                btn.style.background = color;
                btn.dataset.color = color;
                btn.dataset.index = i;
                btn.onclick = () => selectColor(color, i, btn);
                palette.appendChild(btn);
            });

            // íˆ´ ë²„íŠ¼
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.onclick = () => selectTool(btn.dataset.tool, btn);
            });

            // ë¸ŒëŸ¬ì‹œ í¬ê¸°
            const brushSizeInput = document.getElementById('brush-size');
            brushSizeInput.oninput = () => {
                brushSize = parseInt(brushSizeInput.value);
                updateBrushPreview();
            };
            updateBrushPreview();

            // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸
            mainCanvas.addEventListener('mousedown', handleMouseDown);
            mainCanvas.addEventListener('mousemove', handleMouseMove);
            mainCanvas.addEventListener('mouseup', handleMouseUp);
            mainCanvas.addEventListener('mouseleave', handleMouseUp);
            mainCanvas.addEventListener('dblclick', handleDoubleClick);

            // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
            document.addEventListener('keydown', handleKeyDown);

            // ë ˆì´ì–´ íŒ¨ë„ ì´ë²¤íŠ¸
            document.getElementById('bring-front-btn').onclick = () => handleLayerAction('front');
            document.getElementById('send-back-btn').onclick = () => handleLayerAction('back');
            document.getElementById('lock-btn').onclick = () => handleLayerAction('lock');
            document.getElementById('delete-btn').onclick = () => handleLayerAction('delete');

            // íŒ¨ë„ ë“œë˜ê·¸ & ì ‘ê¸° ì„¤ì •
            setupDraggablePanels();

            // í´ë¦¬ì–´ ë²„íŠ¼
            document.getElementById('clear-btn').onclick = clearCanvas;

            // í…ìŠ¤íŠ¸ ì…ë ¥
            document.getElementById('text-input').addEventListener('keydown', handleTextInput);
            document.getElementById('text-input').addEventListener('blur', hideTextInput);

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
            window.addEventListener('resize', resizeCanvas);

            // ì—°ê²° ë²„íŠ¼
            document.getElementById('connect-btn').addEventListener('click', connectWallet);
            document.getElementById('disconnect-btn').addEventListener('click', disconnectWallet);
            document.getElementById('account-select').addEventListener('change', function() {
                const pkInput = document.getElementById('pk-input');
                if (this.value === 'custom') {
                    pkInput.style.display = 'block';
                    pkInput.focus();
                } else {
                    pkInput.style.display = 'none';
                    pkInput.value = '';
                }
            });
            document.getElementById('deploy-btn').addEventListener('click', openBoardModal);
            document.getElementById('use-existing-btn').addEventListener('click', useExistingContract);
            document.getElementById('create-board-btn').addEventListener('click', createBoard);
            document.getElementById('change-registry-btn').addEventListener('click', () => {
                localStorage.removeItem('boardRegistryAddress');
                registryAddress = '';
                registryContract = null;
                loadBoardList();
            });
            document.getElementById('join-btn').addEventListener('click', function() {
                // ë‹‰ë„¤ì„ ëª¨ë‹¬ í‘œì‹œ (ë³´ë“œ ì„ íƒ ì—†ì´ Join ë²„íŠ¼ ì§ì ‘ í´ë¦­í•œ ê²½ìš°)
                showNicknameModal();
            });

            // ë‹‰ë„¤ì„ ëª¨ë‹¬ ì´ë²¤íŠ¸
            document.getElementById('nickname-input').addEventListener('input', function() {
                const value = this.value.trim() || 'Designer';
                document.getElementById('nickname-preview-text').textContent = value;
            });
            document.getElementById('nickname-input').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('nickname-confirm-btn').click();
                }
            });
            document.getElementById('nickname-cancel-btn').addEventListener('click', function() {
                hideNicknameModal();
                document.getElementById('join-btn').disabled = false;
            });
            document.getElementById('nickname-confirm-btn').addEventListener('click', function() {
                const input = document.getElementById('nickname-input');
                userNickname = input.value.trim() || `Designer_${myAddress.slice(-4)}`;
                localStorage.setItem('userNickname', userNickname);
                hideNicknameModal();
                document.getElementById('join-btn').disabled = false;
                joinSession();
            });

            log('Collaboration Board loaded. Connect wallet to start!');
            render();
        }

        function resizeCanvas() {
            const rect = canvasContainer.getBoundingClientRect();
            mainCanvas.width = rect.width;
            mainCanvas.height = rect.height;
            selectionCanvas.width = rect.width;
            selectionCanvas.height = rect.height;
            mainCanvas.style.cursor = getCursorStyle();
            render();
        }

        function getCursorStyle() {
            switch (currentTool) {
                case 'select': return 'default';
                case 'eraser': return 'cell';
                case 'text': return 'text';
                default: return 'crosshair';
            }
        }

        function updateBrushPreview() {
            const brushDot = document.getElementById('brush-dot');
            brushDot.style.width = brushSize + 'px';
            brushDot.style.height = brushSize + 'px';
        }

        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            eventLog.appendChild(entry);
            eventLog.scrollTop = eventLog.scrollHeight;
            while (eventLog.children.length > 50) {
                eventLog.removeChild(eventLog.firstChild);
            }
        }

        // ===== ë„êµ¬/ìƒ‰ìƒ ì„ íƒ =====
        function selectTool(tool, btn) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            mainCanvas.style.cursor = getCursorStyle();

            if (tool !== 'select') {
                selectionSystem.deselectAll();
                renderSelection();
            }
        }

        function selectColor(color, index, btn) {
            currentColor = color;
            currentColorIndex = index;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        // ===== ë Œë”ë§ =====
        function render() {
            canvasRenderer.render();
            renderSelection();
            updateLayerPanel();
            updateStats();
        }

        function renderSelection() {
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            selectionSystem.drawSelection(selectionCtx);
        }

        function updateLayerPanel() {
            const objects = objectManager.getObjectsInLayerOrder().reverse();
            const selectedIds = selectionSystem.selectedIds;

            layerList.innerHTML = objects.map(obj => {
                const icon = getTypeIcon(obj.type);
                const name = getObjectName(obj);
                const selected = selectedIds.has(obj.id) ? 'selected' : '';
                const locked = obj.isLocked ? 'locked' : '';

                return `
                    <div class="layer-item ${selected} ${locked}" data-id="${obj.id}">
                        <span class="layer-icon">${icon}</span>
                        <span class="layer-name">${name}</span>
                        ${obj.isLocked ? 'ğŸ”’' : ''}
                    </div>
                `;
            }).join('');

            // í´ë¦­ ì´ë²¤íŠ¸
            layerList.querySelectorAll('.layer-item').forEach(item => {
                item.onclick = () => {
                    const id = parseInt(item.dataset.id);
                    selectionSystem.selectObject(id);
                    render();
                };
            });

            document.getElementById('object-count').textContent = objects.length;
        }

        function getTypeIcon(type) {
            const icons = {
                stroke: 'âœï¸',
                rectangle: 'â¬œ',
                ellipse: 'â­•',
                line: 'ğŸ“',
                arrow: 'â¡ï¸',
                stickyNote: 'ğŸ“',
                text: 'T'
            };
            return icons[type] || '?';
        }

        function getObjectName(obj) {
            const prefix = obj.type.charAt(0).toUpperCase() + obj.type.slice(1);
            const isOwner = obj.creator?.toLowerCase() === myAddress?.toLowerCase();
            const ownerMark = isOwner ? '' : ' ğŸ”’';
            if (obj.content) {
                return `${prefix}: ${obj.content.slice(0, 10)}${ownerMark}`;
            }
            return `${prefix} #${obj.id}${ownerMark}`;
        }

        function setupDraggablePanels() {
            const panels = document.querySelectorAll('.draggable-panel');

            panels.forEach(panel => {
                const header = panel.querySelector('.panel-header');
                const collapseBtn = panel.querySelector('.collapse-btn');
                const contentId = collapseBtn?.dataset.target;
                const content = document.getElementById(contentId);

                // ì ‘ê¸°/í¼ì¹˜ê¸°
                if (collapseBtn && content) {
                    collapseBtn.onclick = (e) => {
                        e.stopPropagation();
                        content.classList.toggle('collapsed');
                        collapseBtn.textContent = content.classList.contains('collapsed') ? '+' : 'âˆ’';
                    };
                }

                // ë“œë˜ê·¸
                let isDragging = false;
                let startX, startY, startLeft, startTop;

                header.addEventListener('mousedown', (e) => {
                    if (e.target === collapseBtn) return;
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = panel.getBoundingClientRect();
                    startLeft = rect.left;
                    startTop = rect.top;
                    panel.style.transition = 'none';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    panel.style.left = (startLeft + dx) + 'px';
                    panel.style.top = (startTop + dy) + 'px';
                    panel.style.right = 'auto';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        panel.style.transition = '';
                    }
                });
            });
        }

        function updateStats() {
            document.getElementById('tx-sent').textContent = stats.txSent;
        }

        // ===== ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ =====
        function handleMouseDown(e) {
            const { x, y } = getCanvasPoint(e);

            if (currentTool === 'select') {
                handleSelectMouseDown(x, y, e);
            } else if (currentTool === 'pen') {
                handlePenMouseDown(x, y);
            } else if (currentTool === 'eraser') {
                handleEraserMouseDown(x, y);
            } else if (['rect', 'ellipse', 'line', 'arrow'].includes(currentTool)) {
                handleShapeMouseDown(x, y);
            } else if (currentTool === 'sticky') {
                handleStickyCreate(x, y);
            } else if (currentTool === 'text') {
                showTextInput(e.clientX, e.clientY, x, y);
            }
        }

        // ì»¤ì„œ ìœ„ì¹˜ ì „ì†¡ ì“°ë¡œí‹€ë§
        let lastCursorSend = 0;
        const CURSOR_SEND_INTERVAL = 100; // 100msë§ˆë‹¤ ì „ì†¡

        function handleMouseMove(e) {
            const { x, y } = getCanvasPoint(e);

            // ì»¤ì„œ ìœ„ì¹˜ ì „ì†¡ (ì“°ë¡œí‹€ë§)
            if (sessionContract && Date.now() - lastCursorSend > CURSOR_SEND_INTERVAL) {
                lastCursorSend = Date.now();
                sendCursorPosition(x, y);
            }

            if (currentTool === 'select' && selectionSystem.transformMode) {
                selectionSystem.updateTransform({ x, y });
                render();
            } else if (currentTool === 'eraser') {
                // ì§€ìš°ê°œ ì»¤ì„œ í•­ìƒ í‘œì‹œ
                handleEraserMouseMove(x, y);
            } else if (isDrawing) {
                if (currentTool === 'pen') {
                    handlePenMouseMove(x, y);
                } else if (['rect', 'ellipse', 'line', 'arrow'].includes(currentTool)) {
                    handleShapeMouseMove(x, y);
                }
            }
        }

        function handleMouseUp(e) {
            const { x, y } = getCanvasPoint(e);

            if (currentTool === 'select' && selectionSystem.transformMode) {
                handleSelectMouseUp();
            } else if (isDrawing) {
                if (currentTool === 'pen') {
                    handlePenMouseUp();
                } else if (currentTool === 'eraser') {
                    handleEraserMouseUp();
                } else if (['rect', 'ellipse', 'line', 'arrow'].includes(currentTool)) {
                    handleShapeMouseUp(x, y);
                }
            }

            isDrawing = false;
        }

        function handleDoubleClick(e) {
            const { x, y } = getCanvasPoint(e);
            const obj = objectManager.getObjectAtPoint(x, y);

            if (obj && obj.type === 'stickyNote') {
                showStickyEditor(obj);
            }
        }

        function getCanvasPoint(e) {
            const rect = mainCanvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // ===== Select ë„êµ¬ =====
        function handleSelectMouseDown(x, y, e) {
            const handle = selectionSystem.getHandleAtPoint(x, y);

            if (handle) {
                // ë¦¬ì‚¬ì´ì¦ˆ ì „ì— ì†Œìœ ê¶Œ í™•ì¸
                const selectedObjs = selectionSystem.getSelectedObjects();
                const canTransform = selectedObjs.every(obj =>
                    obj.creator?.toLowerCase() === myAddress?.toLowerCase()
                );
                if (canTransform) {
                    selectionSystem.startTransform('resize-' + handle, { x, y });
                } else {
                    log('ë³¸ì¸ì´ ë§Œë“  ê°ì²´ë§Œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤', 'error');
                }
            } else if (selectionSystem.isPointInSelection(x, y)) {
                // ì´ë™ ì „ì— ì†Œìœ ê¶Œ í™•ì¸
                const selectedObjs = selectionSystem.getSelectedObjects();
                const canTransform = selectedObjs.every(obj =>
                    obj.creator?.toLowerCase() === myAddress?.toLowerCase()
                );
                if (canTransform) {
                    selectionSystem.startTransform('move', { x, y });
                } else {
                    log('ë³¸ì¸ì´ ë§Œë“  ê°ì²´ë§Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤', 'error');
                }
            } else {
                const obj = objectManager.getObjectAtPoint(x, y);
                if (obj) {
                    selectionSystem.selectObject(obj.id, e.shiftKey);
                    // ë³¸ì¸ ê°ì²´ì¸ ê²½ìš°ì—ë§Œ ë°”ë¡œ ì´ë™ ì‹œì‘
                    if (obj.creator?.toLowerCase() === myAddress?.toLowerCase()) {
                        selectionSystem.startTransform('move', { x, y });
                    }
                } else {
                    selectionSystem.deselectAll();
                }
                render();
            }
        }

        function handleSelectMouseUp() {
            const result = selectionSystem.endTransform();

            if (result.mode && result.objects.length > 0 && sessionContract) {
                // ì˜¨ì²´ì¸ì— ë³€í™˜ ì „ì†¡
                for (const obj of result.objects) {
                    if (obj.bounds && obj.id >= 0) {
                        if (result.mode === 'move') {
                            sendMoveObject(obj.id, obj.bounds.x, obj.bounds.y);
                        } else if (result.mode.startsWith('resize')) {
                            sendMoveObject(obj.id, obj.bounds.x, obj.bounds.y);
                            sendResizeObject(obj.id, obj.bounds.width, obj.bounds.height);
                        }
                    }
                }
            }

            render();
        }

        // ===== Pen ë„êµ¬ (ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë°) =====
        let strokeStreamTimer = null;
        const STREAM_INTERVAL = 100; // 100msë§ˆë‹¤ ì „ì†¡
        const MIN_POINTS_TO_STREAM = 6; // ìµœì†Œ 3ê°œ ì¢Œí‘œ (6ê°œ ê°’)

        function handlePenMouseDown(x, y) {
            isDrawing = true;
            lastPoint = { x, y };
            strokePoints = [x, y];

            // ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë° íƒ€ì´ë¨¸ ì‹œì‘
            if (sessionContract) {
                strokeStreamTimer = setInterval(() => {
                    streamStrokePoints();
                }, STREAM_INTERVAL);
            }
        }

        function handlePenMouseMove(x, y) {
            if (!lastPoint) return;

            // ë¡œì»¬ ê·¸ë¦¬ê¸°
            mainCtx.beginPath();
            mainCtx.moveTo(lastPoint.x, lastPoint.y);
            mainCtx.lineTo(x, y);
            mainCtx.strokeStyle = currentColor;
            mainCtx.lineWidth = brushSize;
            mainCtx.lineCap = 'round';
            mainCtx.lineJoin = 'round';
            mainCtx.stroke();

            strokePoints.push(x, y);
            lastPoint = { x, y };
        }

        function streamStrokePoints() {
            if (strokePoints.length >= MIN_POINTS_TO_STREAM && sessionContract) {
                const colorIdx = currentColorIndex;
                const width = brushSize;

                // í˜„ì¬ê¹Œì§€ì˜ í¬ì¸íŠ¸ë¡œ ìŠ¤íŠ¸ë¡œí¬ ì „ì†¡
                const pointsToSend = [...strokePoints];

                const obj = {
                    id: objectManager.generateLocalId(),
                    type: 'stroke',
                    creator: myAddress,
                    colorIndex: colorIdx,
                    strokeWidth: width,
                    layer: objectManager.objects.size + 1,
                    points: pointsToSend,
                    bounds: objectManager.calculateStrokeBounds(pointsToSend)
                };

                objectManager.addObject(obj);
                stats.objects++;

                // ì˜¨ì²´ì¸ ì „ì†¡ (ë…¼ë¸”ë¡œí‚¹)
                sendCreateStroke(pointsToSend, colorIdx, width, obj.id);

                // ë§ˆì§€ë§‰ ì ì„ ì‹œì‘ì ìœ¼ë¡œ ìœ ì§€ (ì—°ê²°ì„ ìœ„í•´)
                const lastX = strokePoints[strokePoints.length - 2];
                const lastY = strokePoints[strokePoints.length - 1];
                strokePoints = [lastX, lastY];
            }
        }

        function handlePenMouseUp() {
            // íƒ€ì´ë¨¸ ì •ë¦¬
            if (strokeStreamTimer) {
                clearInterval(strokeStreamTimer);
                strokeStreamTimer = null;
            }

            // ë‚¨ì€ í¬ì¸íŠ¸ ì „ì†¡
            if (strokePoints.length >= 4) {
                const colorIdx = currentColorIndex;
                const width = brushSize;

                const obj = {
                    id: objectManager.generateLocalId(),
                    type: 'stroke',
                    creator: myAddress,
                    colorIndex: colorIdx,
                    strokeWidth: width,
                    layer: objectManager.objects.size + 1,
                    points: [...strokePoints],
                    bounds: objectManager.calculateStrokeBounds(strokePoints)
                };

                objectManager.addObject(obj);
                stats.objects++;

                // ì˜¨ì²´ì¸ ì „ì†¡
                if (sessionContract) {
                    sendCreateStroke(strokePoints, colorIdx, width, obj.id);
                }

                render();
            }

            strokePoints = [];
            lastPoint = null;
        }

        // ===== Eraser ë„êµ¬ (ì˜¤ë¸Œì íŠ¸ ì‚­ì œ) =====
        let erasedObjects = new Set(); // ì´ë¯¸ ì§€ìš´ ì˜¤ë¸Œì íŠ¸ ì¶”ì 
        const ERASER_RADIUS = 25; // ì§€ìš°ê°œ ë°˜ê²½

        function handleEraserMouseDown(x, y) {
            isDrawing = true;
            erasedObjects.clear();
            eraseAtPoint(x, y);
        }

        function handleEraserMouseMove(x, y) {
            // ì§€ìš°ê°œ ë²”ìœ„ í‘œì‹œ
            render();
            mainCtx.beginPath();
            mainCtx.arc(x, y, ERASER_RADIUS, 0, Math.PI * 2);
            mainCtx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
            mainCtx.lineWidth = 2;
            mainCtx.stroke();

            if (!isDrawing) return;
            eraseAtPoint(x, y);
        }

        function handleEraserMouseUp() {
            erasedObjects.clear();
        }

        function eraseAtPoint(x, y) {
            const objects = objectManager.getObjectsInLayerOrder();
            const myAddr = myAddress?.toLowerCase();

            for (const obj of objects) {
                // ì´ë¯¸ ì´ë²ˆ ë“œë˜ê·¸ì—ì„œ ì§€ìš´ ì˜¤ë¸Œì íŠ¸ëŠ” ìŠ¤í‚µ
                if (erasedObjects.has(obj.id)) continue;

                // ì¶©ëŒ ê²€ì‚¬ (ì‚­ì œ ê¶Œí•œì€ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì²´í¬)
                const isNear = isPointNearObject(x, y, obj, ERASER_RADIUS);
                if (isNear) {
                    erasedObjects.add(obj.id);
                    objectManager.deleteObject(obj.id);
                    log(`Erased ${obj.type} #${obj.id}`, 'event');

                    // ì˜¨ì²´ì¸ ì‚­ì œ
                    if (sessionContract && obj.id >= 0) {
                        sendDeleteObject(obj.id);
                    }

                    render();
                }
            }
        }

        function isPointNearObject(px, py, obj, radius) {
            if (!obj.bounds) return false;

            if (obj.type === 'stroke' && obj.points) {
                // ìŠ¤íŠ¸ë¡œí¬: ê° ì„ ë¶„ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                for (let i = 0; i < obj.points.length - 2; i += 2) {
                    const x1 = obj.points[i];
                    const y1 = obj.points[i + 1];
                    const x2 = obj.points[i + 2];
                    const y2 = obj.points[i + 3];

                    if (pointToLineDistance(px, py, x1, y1, x2, y2) < radius + (obj.strokeWidth || 2)) {
                        return true;
                    }
                }
                return false;
            } else {
                // ë„í˜•/ìŠ¤í‹°í‚¤ë…¸íŠ¸/í…ìŠ¤íŠ¸: ë°”ìš´ë”© ë°•ìŠ¤ + ì—¬ìœ  ê³µê°„
                const b = obj.bounds;
                return px >= b.x - radius && px <= b.x + b.width + radius &&
                       py >= b.y - radius && py <= b.y + b.height + radius;
            }
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // ===== Shape ë„êµ¬ =====
        function handleShapeMouseDown(x, y) {
            isDrawing = true;
            shapeStart = { x, y };
        }

        function handleShapeMouseMove(x, y) {
            if (!shapeStart) return;

            // ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸° + ë¯¸ë¦¬ë³´ê¸°
            canvasRenderer.render();

            mainCtx.strokeStyle = currentColor;
            mainCtx.lineWidth = brushSize;

            const w = x - shapeStart.x;
            const h = y - shapeStart.y;

            if (currentTool === 'rect') {
                mainCtx.strokeRect(shapeStart.x, shapeStart.y, w, h);
            } else if (currentTool === 'ellipse') {
                mainCtx.beginPath();
                mainCtx.ellipse(
                    shapeStart.x + w / 2,
                    shapeStart.y + h / 2,
                    Math.abs(w / 2),
                    Math.abs(h / 2),
                    0, 0, Math.PI * 2
                );
                mainCtx.stroke();
            } else if (currentTool === 'line') {
                mainCtx.beginPath();
                mainCtx.moveTo(shapeStart.x, shapeStart.y);
                mainCtx.lineTo(x, y);
                mainCtx.stroke();
            } else if (currentTool === 'arrow') {
                drawArrow(mainCtx, shapeStart.x, shapeStart.y, x, y);
            }
        }

        function handleShapeMouseUp(x, y) {
            if (!shapeStart) return;

            const w = x - shapeStart.x;
            const h = y - shapeStart.y;

            if (Math.abs(w) < 5 && Math.abs(h) < 5) {
                shapeStart = null;
                render();
                return;
            }

            const typeMap = {
                rect: 'rectangle',
                ellipse: 'ellipse',
                line: 'line',
                arrow: 'arrow'
            };

            const obj = {
                id: objectManager.generateLocalId(),
                type: typeMap[currentTool],
                creator: myAddress,
                colorIndex: currentColorIndex,
                strokeWidth: brushSize,
                layer: objectManager.objects.size + 1,
                bounds: {
                    x: Math.min(shapeStart.x, x),
                    y: Math.min(shapeStart.y, y),
                    width: Math.abs(w),
                    height: Math.abs(h)
                },
                rotation: 0
            };

            objectManager.addObject(obj);
            stats.objects++;

            // ì˜¨ì²´ì¸ ì „ì†¡
            if (sessionContract) {
                const shapeTypeNum = CONFIG.objectTypes.indexOf(obj.type);
                sendCreateShape(shapeTypeNum, obj.bounds, 0, currentColorIndex, brushSize, obj.id);
            }

            shapeStart = null;
            render();
        }

        function drawArrow(ctx, x1, y1, x2, y2) {
            const headLen = 15;
            const angle = Math.atan2(y2 - y1, x2 - x1);

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(
                x2 - headLen * Math.cos(angle - Math.PI / 6),
                y2 - headLen * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - headLen * Math.cos(angle + Math.PI / 6),
                y2 - headLen * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        }

        // ===== Sticky Note =====
        function handleStickyCreate(x, y) {
            const obj = {
                id: objectManager.generateLocalId(),
                type: 'stickyNote',
                creator: myAddress,
                colorIndex: 0,
                bgColorIndex: 0,
                strokeWidth: 0,
                layer: objectManager.objects.size + 1,
                bounds: { x, y, width: 200, height: 150 },
                content: '',
                isNew: true  // ì•„ì§ ì˜¨ì²´ì¸ì— ìƒì„± ì•ˆë¨
            };

            objectManager.addObject(obj);
            stats.objects++;
            render();
            showStickyEditor(obj);
        }

        function showStickyEditor(obj) {
            editingStickyId = obj.id;

            const overlay = document.createElement('div');
            overlay.className = 'sticky-editor';
            overlay.id = 'sticky-editor-overlay';
            overlay.style.left = obj.bounds.x + 'px';
            overlay.style.top = obj.bounds.y + 'px';
            overlay.style.width = obj.bounds.width + 'px';
            overlay.style.height = obj.bounds.height + 'px';

            const bgColor = CONFIG.stickyColors[obj.bgColorIndex || 0];

            overlay.innerHTML = `
                <div class="sticky-editor-container" style="background:${bgColor};width:100%;height:100%;">
                    <div class="sticky-color-picker">
                        ${CONFIG.stickyColors.map((c, i) => `
                            <button class="sticky-color-opt ${i === (obj.bgColorIndex || 0) ? 'active' : ''}"
                                    data-index="${i}" style="background:${c}"></button>
                        `).join('')}
                    </div>
                    <textarea class="sticky-textarea">${obj.content || ''}</textarea>
                </div>
            `;

            document.body.appendChild(overlay);

            const textarea = overlay.querySelector('.sticky-textarea');
            let isClosing = false;
            let currentBgIdx = obj.bgColorIndex || 0;

            textarea.focus();

            // ìƒ‰ìƒ ì„ íƒ (mousedownìœ¼ë¡œ blur ë°©ì§€)
            overlay.querySelectorAll('.sticky-color-opt').forEach(btn => {
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // blur ë°©ì§€
                    const idx = parseInt(btn.dataset.index);
                    overlay.querySelector('.sticky-editor-container').style.background = CONFIG.stickyColors[idx];
                    overlay.querySelectorAll('.sticky-color-opt').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentBgIdx = idx;
                    obj.bgColorIndex = idx;
                });
            });

            // ì—ë””í„° ë‹«ê¸° í•¨ìˆ˜
            function closeEditor() {
                if (isClosing) return;
                isClosing = true;

                const content = textarea.value;
                const localObj = objectManager.getObject(obj.id);

                // ë¡œì»¬ ê°ì²´ ì—…ë°ì´íŠ¸
                if (localObj) {
                    localObj.content = content;
                    localObj.bgColorIndex = currentBgIdx;
                }
                obj.content = content;
                obj.bgColorIndex = currentBgIdx;

                if (sessionContract) {
                    const realObj = localObj || obj;
                    const currentId = realObj.id;

                    if (obj.isNew || realObj.isNew) {
                        // ìƒˆ ìŠ¤í‹°í‚¤ - ë‚´ìš©ê³¼ í•¨ê»˜ ìƒì„±
                        sendCreateStickyNote(obj.bounds.x, obj.bounds.y, obj.bounds.width, obj.bounds.height, content, currentBgIdx, obj.id);
                        obj.isNew = false;
                        if (localObj) localObj.isNew = false;
                    } else if (currentId >= 0) {
                        // ê¸°ì¡´ ìŠ¤í‹°í‚¤ ì—…ë°ì´íŠ¸
                        sendUpdateStickyNote(currentId, content);
                    }
                }

                overlay.remove();
                editingStickyId = null;
                render();
            }

            // ì˜¤ë²„ë ˆì´ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeEditor();
                }
            });

            // blur ì‹œ ë‹«ê¸° (ìƒ‰ìƒ ë²„íŠ¼ í´ë¦­ì´ ì•„ë‹ ë•Œë§Œ)
            textarea.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!isClosing && !document.activeElement?.closest('.sticky-editor')) {
                        closeEditor();
                    }
                }, 150);
            });

            // ESCë¡œ ë‹«ê¸°
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeEditor();
                }
            });
        }

        // ===== Text ë„êµ¬ =====
        function showTextInput(clientX, clientY, canvasX, canvasY) {
            const overlay = document.getElementById('text-input-overlay');
            overlay.style.left = clientX + 'px';
            overlay.style.top = clientY + 'px';
            overlay.classList.add('active');
            overlay.dataset.canvasX = canvasX;
            overlay.dataset.canvasY = canvasY;

            const input = document.getElementById('text-input');
            input.value = '';
            input.focus();
        }

        function hideTextInput() {
            document.getElementById('text-input-overlay').classList.remove('active');
        }

        function handleTextInput(e) {
            if (e.key === 'Enter') {
                const overlay = document.getElementById('text-input-overlay');
                const text = document.getElementById('text-input').value;
                const x = parseInt(overlay.dataset.canvasX);
                const y = parseInt(overlay.dataset.canvasY);

                if (text) {
                    const fontSize = brushSize * 5;
                    const metrics = mainCtx.measureText(text);

                    const obj = {
                        id: objectManager.generateLocalId(),
                        type: 'text',
                        creator: myAddress,
                        colorIndex: currentColorIndex,
                        strokeWidth: Math.min(72, Math.max(8, brushSize * 3)),
                        layer: objectManager.objects.size + 1,
                        bounds: { x, y, width: metrics.width || 100, height: fontSize },
                        content: text
                    };

                    objectManager.addObject(obj);
                    stats.objects++;

                    if (sessionContract) {
                        sendCreateText(x, y, text, currentColorIndex, obj.strokeWidth, obj.id);
                    }

                    render();
                }

                hideTextInput();
            } else if (e.key === 'Escape') {
                hideTextInput();
            }
        }

        // ===== í‚¤ë³´ë“œ ì´ë²¤íŠ¸ =====
        function handleKeyDown(e) {
            // ì…ë ¥ ì¤‘ì´ë©´ ë¬´ì‹œ
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.key) {
                case 'Delete':
                case 'Backspace':
                    deleteSelectedObjects();
                    break;
                case 'v':
                case 'V':
                    selectTool('select', document.querySelector('[data-tool="select"]'));
                    break;
                case 'p':
                case 'P':
                    selectTool('pen', document.querySelector('[data-tool="pen"]'));
                    break;
                case 'e':
                case 'E':
                    selectTool('eraser', document.querySelector('[data-tool="eraser"]'));
                    break;
                case 'r':
                case 'R':
                    selectTool('rect', document.querySelector('[data-tool="rect"]'));
                    break;
                case 'o':
                case 'O':
                    selectTool('ellipse', document.querySelector('[data-tool="ellipse"]'));
                    break;
                case 'l':
                case 'L':
                    selectTool('line', document.querySelector('[data-tool="line"]'));
                    break;
                case 'a':
                case 'A':
                    if (!e.ctrlKey && !e.metaKey) {
                        selectTool('arrow', document.querySelector('[data-tool="arrow"]'));
                    }
                    break;
                case 's':
                case 'S':
                    if (!e.ctrlKey && !e.metaKey) {
                        selectTool('sticky', document.querySelector('[data-tool="sticky"]'));
                    }
                    break;
                case 't':
                case 'T':
                    selectTool('text', document.querySelector('[data-tool="text"]'));
                    break;
                case 'Escape':
                    selectionSystem.deselectAll();
                    render();
                    break;
            }
        }

        function deleteSelectedObjects() {
            const selected = selectionSystem.getSelectedObjects();
            for (const obj of selected) {
                objectManager.deleteObject(obj.id);
                if (sessionContract && obj.id >= 0) {
                    sendDeleteObject(obj.id);
                }
            }
            selectionSystem.deselectAll();
            render();
        }

        // ===== ë ˆì´ì–´ ì•¡ì…˜ =====
        function handleLayerAction(action) {
            const selected = selectionSystem.getSelectedObjects();
            if (selected.length === 0) return;

            for (const obj of selected) {
                if (action === 'front') {
                    if (sessionContract && obj.id >= 0) sendBringToFront(obj.id);
                    else if (obj.id < 0) log('Object pending - wait for confirmation', 'error');
                } else if (action === 'back') {
                    if (sessionContract && obj.id >= 0) sendSendToBack(obj.id);
                    else if (obj.id < 0) log('Object pending - wait for confirmation', 'error');
                } else if (action === 'lock') {
                    obj.isLocked = !obj.isLocked;
                    if (sessionContract && obj.id >= 0) sendToggleLock(obj.id);
                } else if (action === 'delete') {
                    objectManager.deleteObject(obj.id);
                    if (sessionContract && obj.id >= 0) {
                        sendDeleteObject(obj.id);
                        log(`Deleted object #${obj.id}`, 'tx');
                    } else if (obj.id < 0) {
                        log('Local object deleted (not yet on chain)', 'event');
                    }
                }
            }

            if (action === 'delete') {
                selectionSystem.deselectAll();
            }
            render();
        }

        // ===== ìº”ë²„ìŠ¤ í´ë¦¬ì–´ =====
        async function clearCanvas() {
            if (sessionContract) {
                try {
                    await sessionContract.clearCanvas({ gasLimit: 100000 });
                    stats.txSent++;
                    log('Canvas cleared', 'tx');
                } catch (error) {
                    log(`Clear error: ${error.message}`, 'error');
                }
            }

            objectManager.clear();
            selectionSystem.deselectAll();
            render();
        }

        // ===== ì˜¨ì²´ì¸ í•¨ìˆ˜ =====
        async function sendCreateStroke(points, colorIndex, strokeWidth, localId) {
            if (!sessionContract) return;

            try {
                const intPoints = points.map(p => Math.round(p));
                const tx = await sessionContract.createStroke(intPoints, colorIndex, strokeWidth, { gasLimit: 500000 });
                const receipt = await tx.wait();

                // ì‹¤ì œ objectId ì¶”ì¶œ
                const event = receipt.events?.find(e => e.event === 'ObjectCreated');
                if (event) {
                    const realId = event.args.objectId.toNumber();
                    updateLocalIdToRealId(localId, realId);
                }

                stats.txSent++;
                log(`Stroke created`, 'tx');
            } catch (error) {
                log(`Stroke error: ${error.message}`, 'error');
            }
        }

        async function sendCreateShape(shapeType, bounds, rotation, colorIndex, strokeWidth, localId) {
            if (!sessionContract) return;

            try {
                const tx = await sessionContract.createShape(
                    shapeType,
                    Math.round(bounds.x),
                    Math.round(bounds.y),
                    Math.round(bounds.width),
                    Math.round(bounds.height),
                    rotation,
                    colorIndex,
                    strokeWidth,
                    { gasLimit: 300000 }
                );
                const receipt = await tx.wait();

                const event = receipt.events?.find(e => e.event === 'ObjectCreated');
                if (event) {
                    const realId = event.args.objectId.toNumber();
                    updateLocalIdToRealId(localId, realId);
                }

                stats.txSent++;
                log(`Shape created`, 'tx');
            } catch (error) {
                log(`Shape error: ${error.message}`, 'error');
            }
        }

        async function sendCreateStickyNote(x, y, width, height, content, bgColorIndex, localId) {
            if (!sessionContract) return;

            try {
                const tx = await sessionContract.createStickyNote(
                    Math.round(x), Math.round(y),
                    Math.round(width), Math.round(height),
                    content, bgColorIndex,
                    { gasLimit: 300000 }
                );
                const receipt = await tx.wait();

                const event = receipt.events?.find(e => e.event === 'ObjectCreated');
                if (event) {
                    const realId = event.args.objectId.toNumber();
                    updateLocalIdToRealId(localId, realId);
                }

                stats.txSent++;
                log(`Sticky note created`, 'tx');
            } catch (error) {
                log(`Sticky note error: ${error.message}`, 'error');
            }
        }

        async function sendCreateText(x, y, content, colorIndex, fontSize, localId) {
            if (!sessionContract) return;

            try {
                const tx = await sessionContract.createText(
                    Math.round(x), Math.round(y),
                    content, colorIndex, fontSize,
                    { gasLimit: 300000 }
                );
                const receipt = await tx.wait();

                const event = receipt.events?.find(e => e.event === 'ObjectCreated');
                if (event) {
                    const realId = event.args.objectId.toNumber();
                    updateLocalIdToRealId(localId, realId);
                }

                stats.txSent++;
                log(`Text created`, 'tx');
            } catch (error) {
                log(`Text error: ${error.message}`, 'error');
            }
        }

        async function sendMoveObject(objectId, newX, newY) {
            if (!sessionContract) return;

            try {
                await sessionContract.moveObject(objectId, Math.round(newX), Math.round(newY), { gasLimit: 150000 });
                stats.txSent++;
            } catch (error) {
                log(`Move error: ${error.message}`, 'error');
            }
        }

        async function sendResizeObject(objectId, newWidth, newHeight) {
            if (!sessionContract) return;

            try {
                await sessionContract.resizeObject(objectId, Math.round(newWidth), Math.round(newHeight), { gasLimit: 150000 });
                stats.txSent++;
            } catch (error) {
                log(`Resize error: ${error.message}`, 'error');
            }
        }

        async function sendDeleteObject(objectId) {
            if (!sessionContract) return;

            try {
                await sessionContract.deleteObject(objectId, { gasLimit: 100000 });
                stats.txSent++;
                log(`Object deleted`, 'tx');
            } catch (error) {
                log(`Delete error: ${error.message}`, 'error');
            }
        }

        async function sendUpdateStickyNote(objectId, content) {
            if (!sessionContract) return;

            try {
                const tx = await sessionContract.updateStickyNote(objectId, content, { gasLimit: 200000 });
                await tx.wait();
                stats.txSent++;
            } catch (error) {
                log(`Update error: ${error.message}`, 'error');
            }
        }

        async function sendCursorPosition(x, y) {
            if (!sessionContract) return;

            try {
                // ë…¼ë¸”ë¡œí‚¹ìœ¼ë¡œ ì „ì†¡ (await ì—†ì´)
                sessionContract.moveCursor(Math.round(x), Math.round(y), { gasLimit: 50000 })
                    .catch(() => {}); // ì—ëŸ¬ ë¬´ì‹œ
            } catch (error) {
                // ë¬´ì‹œ
            }
        }

        async function sendBringToFront(objectId) {
            if (!sessionContract) return;

            try {
                await sessionContract.bringToFront(objectId, { gasLimit: 100000 });
                stats.txSent++;
            } catch (error) {
                log(`Layer error: ${error.message}`, 'error');
            }
        }

        async function sendSendToBack(objectId) {
            if (!sessionContract) return;

            try {
                await sessionContract.sendToBack(objectId, { gasLimit: 100000 });
                stats.txSent++;
            } catch (error) {
                log(`Layer error: ${error.message}`, 'error');
            }
        }

        async function sendToggleLock(objectId) {
            if (!sessionContract) return;

            try {
                await sessionContract.toggleLock(objectId, { gasLimit: 100000 });
                stats.txSent++;
            } catch (error) {
                log(`Lock error: ${error.message}`, 'error');
            }
        }

        function updateLocalIdToRealId(localId, realId) {
            const obj = objectManager.objects.get(localId);
            if (obj) {
                objectManager.objects.delete(localId);
                obj.id = realId;
                objectManager.objects.set(realId, obj);
                objectManager._updateLayerOrder();

                // ì„ íƒ ìƒíƒœ ì—…ë°ì´íŠ¸
                if (selectionSystem.selectedIds.has(localId)) {
                    selectionSystem.selectedIds.delete(localId);
                    selectionSystem.selectedIds.add(realId);
                }

                // ë ˆì´ì–´ íŒ¨ë„ ì—…ë°ì´íŠ¸
                render();
            }
        }

        // Anvil í…ŒìŠ¤íŠ¸ ê³„ì •ë“¤ (ê°ê° 10000 ETH)
        const ANVIL_ACCOUNTS = [
            '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
            '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d',
            '0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a',
            '0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6',
            '0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a'
        ];

        // ===== ì§€ê°‘ ì—°ê²° (Anvil ì§ì ‘ ì—°ê²°) =====
        async function connectWallet() {
            try {
                const accountSelect = document.getElementById('account-select');
                const selectedValue = accountSelect.value;
                const pkInput = document.getElementById('pk-input').value.trim();
                let privateKey;
                let accountLabel;

                if (selectedValue === 'custom') {
                    // Custom private key
                    if (!pkInput) {
                        log('Please enter a private key', 'error');
                        return;
                    }
                    privateKey = pkInput.startsWith('0x') ? pkInput : '0x' + pkInput;
                    accountLabel = 'Custom';
                    log('Connecting with custom private key...');
                } else {
                    // Anvil ê³„ì • ì„ íƒ
                    const accountIndex = parseInt(selectedValue);
                    privateKey = ANVIL_ACCOUNTS[accountIndex];
                    accountLabel = `Anvil #${accountIndex}`;
                    log(`Connecting with ${accountLabel}...`);
                }

                document.getElementById('connect-btn').disabled = true;

                // Anvil ë¡œì»¬ ë…¸ë“œì— ì§ì ‘ ì—°ê²°
                provider = new ethers.providers.JsonRpcProvider(CONFIG.rpcUrl);

                // Private keyë¡œ ì§€ê°‘ ìƒì„±
                signer = new ethers.Wallet(privateKey, provider);
                myAddress = signer.address;

                document.getElementById('connection-status').textContent = `Connected (${accountLabel})`;
                document.getElementById('connection-status').classList.add('connected');
                document.getElementById('my-address').textContent = `${myAddress.slice(0, 6)}...${myAddress.slice(-4)}`;
                document.getElementById('connect-btn').style.display = 'none';
                document.getElementById('disconnect-btn').style.display = 'block';
                document.getElementById('account-select').style.display = 'none';
                document.getElementById('pk-input').style.display = 'none';
                document.getElementById('deploy-btn').disabled = false;

                log(`Connected: ${myAddress}`, 'tx');

                // ì €ì¥ëœ ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œ ë¶ˆëŸ¬ì˜¤ê¸° (ìˆìœ¼ë©´)
                const savedContract = localStorage.getItem('collaborationContract');
                if (savedContract) {
                    document.getElementById('contract-input').value = savedContract;
                }

            } catch (error) {
                log(`Connection error: ${error.message}`, 'error');
                document.getElementById('connect-btn').disabled = false;
            }
        }

        function disconnectWallet() {
            // ìƒíƒœ ì´ˆê¸°í™”
            provider = null;
            signer = null;
            myAddress = null;
            contract = null;
            sessionContract = null;
            contractAddress = null;

            // UI ì´ˆê¸°í™”
            document.getElementById('connection-status').textContent = 'Disconnected';
            document.getElementById('connection-status').classList.remove('connected');
            document.getElementById('my-address').textContent = '';
            document.getElementById('connect-btn').style.display = 'block';
            document.getElementById('connect-btn').disabled = false;
            document.getElementById('disconnect-btn').style.display = 'none';
            document.getElementById('account-select').style.display = 'block';
            document.getElementById('account-select').value = '0';
            document.getElementById('pk-input').style.display = 'none';
            document.getElementById('pk-input').value = '';
            document.getElementById('deploy-btn').disabled = true;
            document.getElementById('deploy-btn').textContent = 'Setup Contract';
            document.getElementById('join-btn').disabled = true;

            log('Disconnected. Select an account to connect.', 'tx');
        }

        // ===== BoardRegistry ê´€ë ¨ í•¨ìˆ˜ =====
        async function openBoardModal() {
            document.getElementById('contract-modal').classList.add('active');
            await loadBoardList();
        }

        async function loadBoardList() {
            const boardListDiv = document.getElementById('board-list');
            boardListDiv.innerHTML = '<div class="board-list-loading">Loading boards...</div>';

            // Registry ì£¼ì†Œ í™•ì¸
            if (!registryAddress) {
                boardListDiv.innerHTML = `
                    <div class="board-list-loading">
                        <p>No BoardRegistry configured.</p>
                        <p class="modal-section-title" style="margin-top:8px;">Enter registry address:</p>
                        <input type="text" id="registry-input" placeholder="0x... (BoardRegistry address)">
                        <button class="btn secondary" id="set-registry-btn" style="margin-top:8px;width:100%;">Set Registry</button>
                    </div>`;

                document.getElementById('set-registry-btn').onclick = async () => {
                    const addr = document.getElementById('registry-input').value.trim();
                    if (addr && ethers.utils.isAddress(addr)) {
                        registryAddress = addr;
                        localStorage.setItem('boardRegistryAddress', registryAddress);
                        log(`Registry set: ${registryAddress.slice(0, 10)}...`, 'tx');
                        await loadBoardList();
                    } else {
                        alert('Enter valid address!');
                    }
                };
                return;
            }

            try {
                registryContract = new ethers.Contract(registryAddress, REGISTRY_ABI, signer);
                const boards = await registryContract.getAllBoards();
                console.log('Loaded boards:', boards);
                boards.forEach((b, i) => console.log(`Board ${i}:`, b.boardAddress, b.name));

                if (boards.length === 0) {
                    boardListDiv.innerHTML = `
                        <div class="board-list-loading">
                            No boards yet. Create one below!
                        </div>`;
                } else {
                    boardListDiv.innerHTML = boards.map((board, index) => {
                        const date = new Date(Number(board.createdAt) * 1000).toLocaleDateString();
                        const creatorShort = `${board.creator.slice(0, 6)}...${board.creator.slice(-4)}`;
                        const deleteMode = board.allowAnyoneDelete ? 'Anyone can delete' : 'Owner only';
                        const badgeClass = board.allowAnyoneDelete ? 'badge-warning' : 'badge-success';
                        return `
                            <div class="board-item" data-address="${board.boardAddress}">
                                <div>
                                    <div class="board-item-name">${board.name || 'Untitled Board'}</div>
                                    <div class="board-item-meta">By ${creatorShort} &bull; ${date}</div>
                                </div>
                                <span class="board-badge ${badgeClass}">${deleteMode}</span>
                            </div>`;
                    }).join('');

                    // ë³´ë“œ í´ë¦­ ì´ë²¤íŠ¸
                    boardListDiv.querySelectorAll('.board-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const addr = item.dataset.address;
                            log(`Selecting board: ${addr}`);
                            console.log('Selecting board:', addr);
                            selectBoard(addr);
                        });
                    });
                }

            } catch (error) {
                log(`Failed to load boards: ${error.message}`, 'error');
                boardListDiv.innerHTML = `
                    <div class="board-list-error">
                        Failed to load boards. Check registry address.
                        <button class="btn secondary" id="reset-registry-btn" style="margin-top:12px;width:100%;">Reset Registry</button>
                    </div>`;

                document.getElementById('reset-registry-btn').onclick = () => {
                    localStorage.removeItem('boardRegistryAddress');
                    registryAddress = '';
                    loadBoardList();
                };
            }
        }

        async function createBoard() {
            const nameInput = document.getElementById('new-board-name');
            const name = nameInput.value.trim();
            const allowAnyoneDelete = document.getElementById('allow-anyone-delete').checked;

            if (!name) {
                alert('Enter a board name!');
                return;
            }

            if (!registryContract) {
                alert('Registry not connected!');
                return;
            }

            const createBtn = document.getElementById('create-board-btn');
            createBtn.disabled = true;
            createBtn.textContent = 'Creating...';

            try {
                log(`Creating board: ${name} (delete: ${allowAnyoneDelete ? 'anyone' : 'owner only'})...`);
                const tx = await registryContract.createBoard(name, allowAnyoneDelete);
                const receipt = await tx.wait();

                // BoardCreated ì´ë²¤íŠ¸ì—ì„œ ì£¼ì†Œ ì¶”ì¶œ
                const event = receipt.events?.find(e => e.event === 'BoardCreated');
                if (event) {
                    const boardAddress = event.args.boardAddress;
                    log(`Board created: ${boardAddress}`, 'tx');
                    nameInput.value = '';
                    await loadBoardList();
                    selectBoard(boardAddress);
                } else {
                    log('Board created!', 'tx');
                    await loadBoardList();
                }

            } catch (error) {
                log(`Create failed: ${error.message}`, 'error');
            } finally {
                createBtn.disabled = false;
                createBtn.textContent = 'Create';
            }
        }

        function resetBoardState() {
            try {
                console.log('resetBoardState: stopping polling');
                // í´ë§ ì¤‘ë‹¨
                if (pollingIntervalId) {
                    clearInterval(pollingIntervalId);
                    pollingIntervalId = null;
                }

                console.log('resetBoardState: reinitializing managers');
                // ì˜¤ë¸Œì íŠ¸ ì´ˆê¸°í™”
                objectManager = new ObjectManager();
                selectionSystem = new SelectionSystem(objectManager);
                canvasRenderer = new CanvasRenderer(mainCanvas, objectManager);

                console.log('resetBoardState: clearing cursors');
                // ì»¤ì„œ ì œê±°
                cursors.forEach((data, addr) => {
                    if (data.element) data.element.remove();
                });
                cursors.clear();

                console.log('resetBoardState: clearing UI');
                // ìœ ì € ëª©ë¡ ì´ˆê¸°í™”
                document.getElementById('users').innerHTML = '';
                document.getElementById('user-count').textContent = '0';

                // ìƒíƒœ ì´ˆê¸°í™”
                isJoined = false;
                sessionContract = null;
                stats = { txSent: 0, objects: 0 };

                // UI ì´ˆê¸°í™”
                document.getElementById('join-btn').disabled = true;
                document.getElementById('join-btn').textContent = 'Join Room';

                console.log('resetBoardState: rendering');
                // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
                render();

                log('Board state reset', 'tx');
                console.log('resetBoardState: complete');
            } catch (error) {
                console.error('resetBoardState error:', error);
            }
        }

        async function selectBoard(boardAddress) {
            console.log('selectBoard called with:', boardAddress);

            if (!boardAddress || !ethers.utils.isAddress(boardAddress)) {
                alert('Invalid board address!');
                console.log('Invalid address');
                return;
            }

            // ê¸°ì¡´ ë³´ë“œ ìƒíƒœ ì´ˆê¸°í™”
            console.log('Calling resetBoardState...');
            resetBoardState();
            console.log('resetBoardState done');

            contractAddress = boardAddress;
            contract = new ethers.Contract(contractAddress, CONTRACT_ABI, signer);
            console.log('Contract created');

            try {
                console.log('Calling canvasVersion...');
                const version = await contract.canvasVersion();
                console.log('Version:', version);
                log(`Selected board (version ${version})`, 'tx');
                localStorage.setItem('collaborationContract', contractAddress);

                document.getElementById('contract-modal').classList.remove('active');
                document.getElementById('deploy-btn').textContent = 'Board Selected';

                // ë‹‰ë„¤ì„ ëª¨ë‹¬ í‘œì‹œ
                showNicknameModal();

            } catch (error) {
                console.error('selectBoard error:', error);
                log(`Invalid board: ${error.message}`, 'error');
            }
        }

        async function useExistingContract() {
            const address = document.getElementById('contract-input').value.trim();
            if (!address || !ethers.utils.isAddress(address)) {
                alert('Enter valid contract address!');
                return;
            }

            contractAddress = address;
            contract = new ethers.Contract(contractAddress, CONTRACT_ABI, signer);

            try {
                const version = await contract.canvasVersion();
                log(`Connected to contract (version ${version})`, 'tx');
                localStorage.setItem('collaborationContract', contractAddress);

                document.getElementById('contract-modal').classList.remove('active');
                document.getElementById('deploy-btn').textContent = 'Contract Ready';
                document.getElementById('join-btn').disabled = false;

            } catch (error) {
                log(`Invalid contract: ${error.message}`, 'error');
            }
        }

        function showNicknameModal() {
            const modal = document.getElementById('nickname-modal');
            const input = document.getElementById('nickname-input');
            const preview = document.getElementById('nickname-preview-text');

            // ì €ì¥ëœ ë‹‰ë„¤ì„ì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’
            const savedNickname = localStorage.getItem('userNickname');
            const defaultNickname = savedNickname || `Designer_${myAddress.slice(-4)}`;
            input.value = defaultNickname;
            preview.textContent = defaultNickname;

            modal.classList.add('active');
            input.focus();
            input.select();
        }

        function hideNicknameModal() {
            document.getElementById('nickname-modal').classList.remove('active');
        }

        async function joinSession() {
            const joinBtn = document.getElementById('join-btn');

            try {
                joinBtn.disabled = true;
                joinBtn.innerHTML = '<span class="spinner"></span> Joining...';

                // ë©”ì¸ ì§€ê°‘ ì§ì ‘ ì‚¬ìš© (ì„¸ì…˜ ì›”ë › ëŒ€ì‹ )
                sessionContract = new ethers.Contract(contractAddress, CONTRACT_ABI, signer);

                let nickname = userNickname || `Designer_${myAddress.slice(-4)}`;

                // ì´ë¯¸ ì°¸ê°€í–ˆëŠ”ì§€ í™•ì¸
                try {
                    const userInfo = await sessionContract.getUserInfo(myAddress);
                    if (userInfo.isActive) {
                        // ì¬ì ‘ì†: ë‹‰ë„¤ì„ì´ ë‹¤ë¥´ë©´ ì—…ë°ì´íŠ¸
                        const storedNickname = userInfo.nickname;
                        if (userNickname && userNickname !== storedNickname) {
                            log(`Updating nickname to ${userNickname}...`);
                            const tx = await sessionContract.updateNickname(userNickname);
                            await tx.wait();
                            stats.txSent++;
                            nickname = userNickname;
                        } else {
                            nickname = storedNickname || nickname;
                        }
                        log(`Reconnected as ${nickname}`, 'tx');
                    } else {
                        log(`Joining as ${nickname}...`);
                        const tx = await sessionContract.join(nickname);
                        await tx.wait();
                        stats.txSent++;
                    }
                } catch (e) {
                    // getUserInfo ì‹¤íŒ¨ ì‹œ join ì‹œë„
                    log(`Joining as ${nickname}...`);
                    const tx = await sessionContract.join(nickname);
                    await tx.wait();
                    stats.txSent++;
                }

                isJoined = true;

                document.getElementById('my-address').textContent = `${myAddress.slice(0, 6)}...${myAddress.slice(-4)}`;
                createCursor(myAddress, nickname);

                // ê¸°ì¡´ ê·¸ë¦¼ ë¶ˆëŸ¬ì˜¤ê¸°
                log('Loading existing drawings...');
                await loadInitialState();

                // ì´ë²¤íŠ¸ í´ë§ ì‹œì‘
                startEventPolling();

                joinBtn.textContent = 'Joined!';
                log('Joined! Start collaborating.', 'tx');

            } catch (error) {
                log(`Join error: ${error.message}`, 'error');
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join Room';
            }
        }

        // ===== ì»¤ì„œ ê´€ë¦¬ =====
        function getColorForAddress(address) {
            const index = parseInt(address.slice(-4), 16) % CONFIG.colors.length;
            return CONFIG.colors[index];
        }

        function createCursor(address, nickname) {
            const addr = address.toLowerCase();

            // ì´ë¯¸ ì»¤ì„œê°€ ìˆìœ¼ë©´ ë‹‰ë„¤ì„ë§Œ ì—…ë°ì´íŠ¸
            if (cursors.has(addr)) {
                const existing = cursors.get(addr);
                if (existing.nickname !== nickname) {
                    existing.nickname = nickname;
                    const label = existing.element.querySelector('.cursor-label');
                    if (label) label.textContent = nickname;
                    updateUserList();
                }
                return;
            }

            const color = getColorForAddress(address);
            const cursor = document.createElement('div');
            cursor.className = 'remote-cursor';
            cursor.style.setProperty('--cursor-color', color);
            cursor.innerHTML = `
                <div class="cursor-pointer"></div>
                <div class="cursor-label">${nickname}</div>
            `;

            cursorLayer.appendChild(cursor);
            cursors.set(addr, { element: cursor, nickname, color });
            updateUserList();
        }

        function updateRemoteCursor(address, x, y) {
            const addr = address.toLowerCase();
            const cursorData = cursors.get(addr);

            if (!cursorData) {
                // ì»¤ì„œê°€ ì—†ìœ¼ë©´ ìƒì„±
                createCursor(address, `User_${address.slice(-4)}`);
                return updateRemoteCursor(address, x, y);
            }

            const posX = typeof x === 'object' ? x.toNumber() : x;
            const posY = typeof y === 'object' ? y.toNumber() : y;

            cursorData.element.style.left = posX + 'px';
            cursorData.element.style.top = posY + 'px';
            cursorData.element.style.display = 'block';
        }

        function updateUserList() {
            const usersEl = document.getElementById('users');
            usersEl.innerHTML = '';
            document.getElementById('user-count').textContent = cursors.size;

            cursors.forEach((cursor, address) => {
                const isMe = address.toLowerCase() === myAddress?.toLowerCase();
                const item = document.createElement('div');
                item.className = 'user-item';
                item.innerHTML = `
                    <div class="user-dot" style="background: ${cursor.color}"></div>
                    <div class="user-name">${cursor.nickname}${isMe ? ' (me)' : ''}</div>
                `;
                usersEl.appendChild(item);
            });
        }

        // ===== ì´ˆê¸° ìƒíƒœ ë¡œë“œ =====
        async function loadInitialState() {
            try {
                const currentBlock = await provider.getBlockNumber();

                // ë§ˆì§€ë§‰ CanvasCleared ì´ë²¤íŠ¸ ì°¾ê¸°
                const clearEvents = await contract.queryFilter(
                    contract.filters.CanvasCleared(),
                    0, currentBlock
                );

                let fromBlock = 0;
                if (clearEvents.length > 0) {
                    // ë§ˆì§€ë§‰ í´ë¦¬ì–´ ì´í›„ë¶€í„° ë¡œë“œ
                    fromBlock = clearEvents[clearEvents.length - 1].blockNumber;
                    log(`Loading from block ${fromBlock} (after canvas clear)`);
                }

                // ì‚­ì œëœ ì˜¤ë¸Œì íŠ¸ ID ìˆ˜ì§‘
                const deletedIds = new Set();
                const deletedEvents = await contract.queryFilter(
                    contract.filters.ObjectDeleted(),
                    fromBlock, currentBlock
                );
                for (const event of deletedEvents) {
                    deletedIds.add(event.args.objectId.toNumber());
                }

                // StrokePoints ë¡œë“œ
                const strokeEvents = await contract.queryFilter(
                    contract.filters.StrokePoints(),
                    fromBlock, currentBlock
                );

                for (const event of strokeEvents) {
                    const { objectId, points } = event.args;
                    const id = objectId.toNumber();

                    if (deletedIds.has(id)) continue;
                    if (objectManager.objects.has(id)) continue;

                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.isDeleted) continue;

                        const obj = {
                            id,
                            type: 'stroke',
                            creator: info.creator,
                            colorIndex: info.colorIndex,
                            strokeWidth: info.strokeWidth,
                            layer: info.layer,
                            points: points.map(p => p.toNumber ? p.toNumber() : p),
                            bounds: null
                        };
                        obj.bounds = objectManager.calculateStrokeBounds(obj.points);
                        objectManager.addObject(obj);
                    } catch (e) { }
                }

                // ShapeGeometry ë¡œë“œ
                const shapeEvents = await contract.queryFilter(
                    contract.filters.ShapeGeometry(),
                    fromBlock, currentBlock
                );

                for (const event of shapeEvents) {
                    const { objectId, x, y, width, height, rotation } = event.args;
                    const id = objectId.toNumber();

                    if (deletedIds.has(id)) continue;
                    if (objectManager.objects.has(id)) continue;

                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.isDeleted) continue;

                        const obj = {
                            id,
                            type: CONFIG.objectTypes[info.objectType],
                            creator: info.creator,
                            colorIndex: info.colorIndex,
                            strokeWidth: info.strokeWidth,
                            layer: info.layer,
                            bounds: {
                                x: x.toNumber ? x.toNumber() : x,
                                y: y.toNumber ? y.toNumber() : y,
                                width: width.toNumber ? width.toNumber() : width,
                                height: height.toNumber ? height.toNumber() : height
                            },
                            rotation: rotation.toNumber ? rotation.toNumber() : rotation
                        };
                        objectManager.addObject(obj);
                    } catch (e) { }
                }

                // StickyNoteData ë¡œë“œ
                const stickyEvents = await contract.queryFilter(
                    contract.filters.StickyNoteData(),
                    fromBlock, currentBlock
                );

                for (const event of stickyEvents) {
                    const { objectId, x, y, width, height, content, bgColorIndex } = event.args;
                    const id = objectId.toNumber();

                    if (deletedIds.has(id)) continue;
                    if (objectManager.objects.has(id)) continue;

                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.isDeleted) continue;

                        const obj = {
                            id,
                            type: 'stickyNote',
                            creator: info.creator,
                            colorIndex: info.colorIndex,
                            bgColorIndex,
                            strokeWidth: 0,
                            layer: info.layer,
                            bounds: {
                                x: x.toNumber ? x.toNumber() : x,
                                y: y.toNumber ? y.toNumber() : y,
                                width: width.toNumber ? width.toNumber() : width,
                                height: height.toNumber ? height.toNumber() : height
                            },
                            content
                        };
                        objectManager.addObject(obj);
                    } catch (e) { }
                }

                // TextData ë¡œë“œ
                const textEvents = await contract.queryFilter(
                    contract.filters.TextData(),
                    fromBlock, currentBlock
                );

                for (const event of textEvents) {
                    const { objectId, x, y, content, fontSize } = event.args;
                    const id = objectId.toNumber();

                    if (deletedIds.has(id)) continue;
                    if (objectManager.objects.has(id)) continue;

                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.isDeleted) continue;

                        const obj = {
                            id,
                            type: 'text',
                            creator: info.creator,
                            colorIndex: info.colorIndex,
                            strokeWidth: fontSize,
                            layer: info.layer,
                            bounds: {
                                x: x.toNumber ? x.toNumber() : x,
                                y: y.toNumber ? y.toNumber() : y,
                                width: 100,
                                height: fontSize * 5
                            },
                            content
                        };
                        objectManager.addObject(obj);
                    } catch (e) { }
                }

                // ì´ë™ëœ ì˜¤ë¸Œì íŠ¸ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                const movedEvents = await contract.queryFilter(
                    contract.filters.ObjectMoved(),
                    fromBlock, currentBlock
                );

                for (const event of movedEvents) {
                    const { objectId, newX, newY } = event.args;
                    const id = objectId.toNumber();
                    const obj = objectManager.getObject(id);
                    if (obj && obj.bounds) {
                        const newXVal = newX.toNumber ? newX.toNumber() : newX;
                        const newYVal = newY.toNumber ? newY.toNumber() : newY;
                        const dx = newXVal - obj.bounds.x;
                        const dy = newYVal - obj.bounds.y;

                        obj.bounds.x = newXVal;
                        obj.bounds.y = newYVal;

                        // ìŠ¤íŠ¸ë¡œí¬ì˜ ê²½ìš° í¬ì¸íŠ¸ë„ ì´ë™
                        if (obj.type === 'stroke' && obj.points) {
                            for (let i = 0; i < obj.points.length; i += 2) {
                                obj.points[i] += dx;
                                obj.points[i + 1] += dy;
                            }
                        }
                    }
                }

                // ê¸°ì¡´ ìœ ì € ëª©ë¡ ë¡œë“œ
                const joinEvents = await contract.queryFilter(
                    contract.filters.UserJoined(),
                    0, currentBlock
                );

                const leftEvents = await contract.queryFilter(
                    contract.filters.UserLeft(),
                    0, currentBlock
                );

                // ë– ë‚œ ìœ ì € ì£¼ì†Œ ìˆ˜ì§‘
                const leftUsers = new Set();
                for (const event of leftEvents) {
                    leftUsers.add(event.args.user.toLowerCase());
                }

                // í™œì„± ìœ ì €ë§Œ ì¶”ê°€
                for (const event of joinEvents) {
                    const { user, nickname } = event.args;
                    const addr = user.toLowerCase();

                    // ë– ë‚œ ìœ ì €ëŠ” ìŠ¤í‚µ, ë‚˜ ìì‹ ë„ ìŠ¤í‚µ (ì´ë¯¸ ì¶”ê°€ë¨)
                    if (leftUsers.has(addr)) continue;
                    if (addr === myAddress?.toLowerCase()) continue;

                    createCursor(user, nickname);
                }

                stats.objects = objectManager.objects.size;
                render();
                log(`Loaded ${objectManager.objects.size} objects, ${cursors.size} users`, 'tx');

            } catch (error) {
                log(`Load error: ${error.message}`, 'error');
            }
        }

        // ===== ì´ë²¤íŠ¸ í´ë§ =====
        function startEventPolling() {
            // ê¸°ì¡´ í´ë§ ì¤‘ë‹¨
            if (pollingIntervalId) {
                clearInterval(pollingIntervalId);
            }

            let lastBlock = 0;

            // 100ms í´ë§ìœ¼ë¡œ ì‹¤ì‹œê°„ ë™ê¸°í™”
            pollingIntervalId = setInterval(async () => {
                try {
                    const currentBlock = await provider.getBlockNumber();
                    if (lastBlock === 0) lastBlock = currentBlock - 1;

                    if (currentBlock > lastBlock) {
                        await processEvents(lastBlock + 1, currentBlock);
                        lastBlock = currentBlock;
                    }
                } catch (error) {
                    // ë¬´ì‹œ
                }
            }, 100);
        }

        async function processEvents(fromBlock, toBlock) {
            // ObjectCreated
            const createdEvents = await contract.queryFilter(
                contract.filters.ObjectCreated(),
                fromBlock, toBlock
            );

            for (const event of createdEvents) {
                const { creator, objectId, objectType, colorIndex, strokeWidth, layer } = event.args;
                if (creator.toLowerCase() === myAddress?.toLowerCase()) continue;

                // ë‹¤ë¥¸ ìœ ì €ê°€ ë§Œë“  ì˜¤ë¸Œì íŠ¸ - geometry ì´ë²¤íŠ¸ í•„ìš”
                log(`New object from ${creator.slice(0, 8)}...`, 'event');
            }

            // StrokePoints
            const strokeEvents = await contract.queryFilter(
                contract.filters.StrokePoints(),
                fromBlock, toBlock
            );

            for (const event of strokeEvents) {
                const { objectId, points } = event.args;
                const id = objectId.toNumber();

                if (!objectManager.objects.has(id)) {
                    // ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.creator.toLowerCase() !== myAddress?.toLowerCase()) {
                            const obj = {
                                id,
                                type: 'stroke',
                                creator: info.creator,
                                colorIndex: info.colorIndex,
                                strokeWidth: info.strokeWidth,
                                layer: info.layer,
                                points: points.map(p => p.toNumber ? p.toNumber() : p),
                                bounds: null
                            };
                            obj.bounds = objectManager.calculateStrokeBounds(obj.points);
                            objectManager.addObject(obj);
                            render();
                        }
                    } catch (e) { }
                }
            }

            // ShapeGeometry
            const shapeEvents = await contract.queryFilter(
                contract.filters.ShapeGeometry(),
                fromBlock, toBlock
            );

            for (const event of shapeEvents) {
                const { objectId, x, y, width, height, rotation } = event.args;
                const id = objectId.toNumber();

                if (!objectManager.objects.has(id)) {
                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.creator.toLowerCase() !== myAddress?.toLowerCase()) {
                            const obj = {
                                id,
                                type: CONFIG.objectTypes[info.objectType],
                                creator: info.creator,
                                colorIndex: info.colorIndex,
                                strokeWidth: info.strokeWidth,
                                layer: info.layer,
                                bounds: {
                                    x: x.toNumber ? x.toNumber() : x,
                                    y: y.toNumber ? y.toNumber() : y,
                                    width: width.toNumber ? width.toNumber() : width,
                                    height: height.toNumber ? height.toNumber() : height
                                },
                                rotation: rotation.toNumber ? rotation.toNumber() : rotation
                            };
                            objectManager.addObject(obj);
                            render();
                        }
                    } catch (e) { }
                }
            }

            // StickyNoteData
            const stickyEvents = await contract.queryFilter(
                contract.filters.StickyNoteData(),
                fromBlock, toBlock
            );

            for (const event of stickyEvents) {
                const { objectId, x, y, width, height, content, bgColorIndex } = event.args;
                const id = objectId.toNumber();

                if (!objectManager.objects.has(id)) {
                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.creator.toLowerCase() !== myAddress?.toLowerCase()) {
                            const obj = {
                                id,
                                type: 'stickyNote',
                                creator: info.creator,
                                colorIndex: info.colorIndex,
                                bgColorIndex,
                                strokeWidth: 0,
                                layer: info.layer,
                                bounds: {
                                    x: x.toNumber ? x.toNumber() : x,
                                    y: y.toNumber ? y.toNumber() : y,
                                    width: width.toNumber ? width.toNumber() : width,
                                    height: height.toNumber ? height.toNumber() : height
                                },
                                content
                            };
                            objectManager.addObject(obj);
                            render();
                        }
                    } catch (e) { }
                }
            }

            // TextData
            const textEvents = await contract.queryFilter(
                contract.filters.TextData(),
                fromBlock, toBlock
            );

            for (const event of textEvents) {
                const { objectId, x, y, content, fontSize } = event.args;
                const id = objectId.toNumber();

                if (!objectManager.objects.has(id)) {
                    try {
                        const info = await contract.getObjectInfo(id);
                        if (info.creator.toLowerCase() !== myAddress?.toLowerCase()) {
                            const obj = {
                                id,
                                type: 'text',
                                creator: info.creator,
                                colorIndex: info.colorIndex,
                                strokeWidth: fontSize,
                                layer: info.layer,
                                bounds: {
                                    x: x.toNumber ? x.toNumber() : x,
                                    y: y.toNumber ? y.toNumber() : y,
                                    width: 100,
                                    height: fontSize * 5
                                },
                                content
                            };
                            objectManager.addObject(obj);
                            render();
                        }
                    } catch (e) { }
                }
            }

            // ObjectMoved
            const movedEvents = await contract.queryFilter(
                contract.filters.ObjectMoved(),
                fromBlock, toBlock
            );

            for (const event of movedEvents) {
                const { user, objectId, newX, newY } = event.args;
                if (user.toLowerCase() === myAddress?.toLowerCase()) continue;

                const id = objectId.toNumber();
                const obj = objectManager.getObject(id);
                if (obj && obj.bounds) {
                    const newXVal = newX.toNumber ? newX.toNumber() : newX;
                    const newYVal = newY.toNumber ? newY.toNumber() : newY;
                    const dx = newXVal - obj.bounds.x;
                    const dy = newYVal - obj.bounds.y;

                    obj.bounds.x = newXVal;
                    obj.bounds.y = newYVal;

                    // ìŠ¤íŠ¸ë¡œí¬ì˜ ê²½ìš° í¬ì¸íŠ¸ë„ ì´ë™
                    if (obj.type === 'stroke' && obj.points) {
                        for (let i = 0; i < obj.points.length; i += 2) {
                            obj.points[i] += dx;
                            obj.points[i + 1] += dy;
                        }
                    }
                    render();
                }
            }

            // ObjectDeleted
            const deletedEvents = await contract.queryFilter(
                contract.filters.ObjectDeleted(),
                fromBlock, toBlock
            );

            for (const event of deletedEvents) {
                const { user, objectId } = event.args;
                const id = typeof objectId === 'bigint' ? Number(objectId) : (objectId.toNumber ? objectId.toNumber() : objectId);
                console.log(`[Delete Event] user=${user}, objectId=${id}, myAddress=${myAddress}`);

                if (user.toLowerCase() === myAddress?.toLowerCase()) {
                    console.log('[Delete Event] Skipping - my own delete');
                    continue;
                }

                log(`Object #${id} deleted by ${user.slice(0, 8)}...`, 'event');
                objectManager.deleteObject(id);
            }

            // ContentUpdated (ìŠ¤í‹°í‚¤ ë…¸íŠ¸, í…ìŠ¤íŠ¸ ë‚´ìš© ì—…ë°ì´íŠ¸)
            const contentEvents = await contract.queryFilter(
                contract.filters.ContentUpdated(),
                fromBlock, toBlock
            );

            for (const event of contentEvents) {
                const { objectId, newContent } = event.args;
                const id = objectId.toNumber ? objectId.toNumber() : Number(objectId);
                const obj = objectManager.getObject(id);
                if (obj) {
                    obj.content = newContent;
                    log(`Content updated for #${id}`, 'event');
                    render();
                }
            }

            // CanvasCleared
            const clearEvents = await contract.queryFilter(
                contract.filters.CanvasCleared(),
                fromBlock, toBlock
            );

            if (clearEvents.length > 0) {
                const lastClear = clearEvents[clearEvents.length - 1];
                if (lastClear.args.user.toLowerCase() !== myAddress?.toLowerCase()) {
                    objectManager.clear();
                    selectionSystem.deselectAll();
                    render();
                    log('Canvas cleared by another user', 'event');
                }
            }

            // CursorMoved
            const cursorEvents = await contract.queryFilter(
                contract.filters.CursorMoved(),
                fromBlock, toBlock
            );

            for (const event of cursorEvents) {
                const { user, x, y } = event.args;
                if (user.toLowerCase() !== myAddress?.toLowerCase()) {
                    updateRemoteCursor(user, x, y);
                }
            }

            // UserJoined
            const joinEvents = await contract.queryFilter(
                contract.filters.UserJoined(),
                fromBlock, toBlock
            );

            for (const event of joinEvents) {
                const { user, nickname } = event.args;
                if (user.toLowerCase() !== myAddress?.toLowerCase()) {
                    createCursor(user, nickname);
                    log(`${nickname} joined`, 'event');
                }
            }

            // NicknameUpdated
            const nicknameEvents = await contract.queryFilter(
                contract.filters.NicknameUpdated(),
                fromBlock, toBlock
            );

            for (const event of nicknameEvents) {
                const { user, newNickname } = event.args;
                createCursor(user, newNickname);  // createCursorëŠ” ì´ë¯¸ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸í•¨
                if (user.toLowerCase() !== myAddress?.toLowerCase()) {
                    log(`${newNickname} updated nickname`, 'event');
                }
            }

            // í•­ìƒ ë Œë”ë§ (ë™ê¸°í™” ë³´ì¥)
            render();
        }

        // ===== ì‹œì‘ =====
        window.onerror = function(msg, url, line, col, error) {
            console.error('Error:', msg, 'Line:', line);
            alert('JavaScript Error: ' + msg + ' (Line: ' + line + ')');
            return false;
        };

        try {
            init();
            console.log('Init completed successfully');
        } catch (e) {
            console.error('Init error:', e);
            alert('Init error: ' + e.message);
        }
    </script>
</body>
</html>
