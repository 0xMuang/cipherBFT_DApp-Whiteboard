<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onchain Whiteboard - Real-time Collaboration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            overflow: hidden;
            color: #fff;
        }

        /* Î©îÏù∏ Ï∫îÎ≤ÑÏä§ */
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #whiteboard {
            position: absolute;
            top: 0;
            left: 0;
            background: #ffffff;
            cursor: crosshair;
        }

        #cursor-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* Ïª§ÏÑú Ïä§ÌÉÄÏùº */
        .remote-cursor {
            position: absolute;
            pointer-events: none;
            transition: left 0.05s linear, top 0.05s linear;
            z-index: 100;
        }

        .cursor-pointer {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 16px solid var(--cursor-color, #00ff88);
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 4px var(--cursor-color, #00ff88));
        }

        .cursor-label {
            position: absolute;
            left: 16px;
            top: 10px;
            background: var(--cursor-color, #00ff88);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            white-space: nowrap;
        }

        /* ÏÉÅÎã® Ìà¥Î∞î */
        #toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 1000;
        }

        .tool-group {
            display: flex;
            gap: 6px;
            padding-right: 12px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tool-group:last-child {
            border-right: none;
            padding-right: 0;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
        }

        /* ÏÉâÏÉÅ ÌåîÎ†àÌä∏ */
        #color-palette {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 120px;
        }

        .color-btn {
            width: 24px;
            height: 24px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.15);
        }

        .color-btn.active {
            border-color: #fff;
            box-shadow: 0 0 8px currentColor;
        }

        /* Î∏åÎü¨Ïãú ÌÅ¨Í∏∞ */
        #brush-size {
            width: 80px;
            accent-color: #00ff88;
        }

        #brush-preview {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #brush-dot {
            background: #fff;
            border-radius: 50%;
        }

        /* Ï¢åÏ∏° Ìå®ÎÑê */
        #left-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 200px;
            z-index: 1000;
        }

        #left-panel h1 {
            font-size: 16px;
            margin-bottom: 4px;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 11px;
            color: #666;
            margin-bottom: 16px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .status-label {
            color: #888;
        }

        .status-value {
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        .status-value.connected {
            color: #00ff88;
        }

        /* Ïö∞Ï∏° Ìå®ÎÑê - Ïú†Ï†Ä Î¶¨Ïä§Ìä∏ */
        #right-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 180px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
        }

        #right-panel h2 {
            font-size: 13px;
            color: #888;
            margin-bottom: 12px;
        }

        .user-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .user-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .user-name {
            font-size: 12px;
        }

        /* ÌïòÎã® Ïó∞Í≤∞ Î≤ÑÌäº */
        #connect-area {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
        }

        .btn {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
            border: none;
            padding: 12px 28px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.4);
        }

        .btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        /* Î™®Îã¨ */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 450px;
            width: 90%;
        }

        .modal h2 {
            margin-bottom: 16px;
            color: #00ff88;
        }

        .modal p {
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .modal input {
            width: 100%;
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 14px;
            margin-bottom: 16px;
        }

        .modal input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .modal .btn-group {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Î°úÍ∑∏ */
        #event-log {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 280px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            z-index: 1000;
        }

        .log-entry {
            color: #666;
            margin-bottom: 3px;
        }

        .log-entry.tx { color: #00ff88; }
        .log-entry.event { color: #00ccff; }
        .log-entry.error { color: #ff6b6b; }

        /* Ïä§ÌîºÎÑà */
        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ÌÖçÏä§Ìä∏ ÏûÖÎ†• */
        #text-input-overlay {
            display: none;
            position: fixed;
            z-index: 1500;
        }

        #text-input-overlay.active {
            display: block;
        }

        #text-input-overlay input {
            padding: 8px 12px;
            font-size: 16px;
            border: 2px solid #00ff88;
            border-radius: 8px;
            background: #fff;
            color: #000;
            min-width: 150px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="whiteboard"></canvas>
        <div id="cursor-layer"></div>
    </div>

    <!-- ÏÉÅÎã® Ìà¥Î∞î -->
    <div id="toolbar">
        <div class="tool-group">
            <button class="tool-btn active" data-tool="pen" title="Pen">‚úèÔ∏è</button>
            <button class="tool-btn" data-tool="eraser" title="Eraser">üßΩ</button>
        </div>
        <div class="tool-group">
            <button class="tool-btn" data-tool="rect" title="Rectangle">‚¨ú</button>
            <button class="tool-btn" data-tool="circle" title="Circle">‚≠ï</button>
            <button class="tool-btn" data-tool="arrow" title="Arrow">‚û°Ô∏è</button>
            <button class="tool-btn" data-tool="text" title="Text">T</button>
        </div>
        <div class="tool-group" id="color-palette"></div>
        <div class="tool-group">
            <input type="range" id="brush-size" min="1" max="20" value="3">
            <div id="brush-preview"><div id="brush-dot"></div></div>
        </div>
        <div class="tool-group">
            <button class="tool-btn" id="clear-btn" title="Clear Canvas">üóëÔ∏è</button>
            <button class="tool-btn" id="undo-btn" title="Undo">‚Ü©Ô∏è</button>
        </div>
    </div>

    <!-- Ï¢åÏ∏° ÏÉÅÌÉú Ìå®ÎÑê -->
    <div id="left-panel">
        <h1>Onchain Whiteboard</h1>
        <div class="subtitle">Real-time collaboration on blockchain</div>
        <div class="status-row">
            <span class="status-label">Status</span>
            <span class="status-value" id="connection-status">Not Connected</span>
        </div>
        <div class="status-row">
            <span class="status-label">Address</span>
            <span class="status-value" id="my-address">-</span>
        </div>
        <div class="status-row">
            <span class="status-label">Strokes</span>
            <span class="status-value" id="stroke-count">0</span>
        </div>
        <div class="status-row">
            <span class="status-label">TX Sent</span>
            <span class="status-value" id="tx-sent">0</span>
        </div>
    </div>

    <!-- Ïö∞Ï∏° Ïú†Ï†Ä Ìå®ÎÑê -->
    <div id="right-panel">
        <h2>Online (<span id="user-count">0</span>)</h2>
        <div id="users"></div>
    </div>

    <!-- Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ -->
    <div id="event-log" id="log-content"></div>

    <!-- Ïó∞Í≤∞ Î≤ÑÌäº -->
    <div id="connect-area">
        <button class="btn" id="connect-btn">Connect Wallet</button>
        <button class="btn secondary" id="deploy-btn" disabled>Setup Contract</button>
        <button class="btn secondary" id="join-btn" disabled>Join Room</button>
    </div>

    <!-- Ïª®Ìä∏ÎûôÌä∏ Î™®Îã¨ -->
    <div class="modal" id="contract-modal">
        <div class="modal-content">
            <h2>Contract Setup</h2>
            <p>Enter existing contract or deploy new one.</p>
            <input type="text" id="contract-input" placeholder="0x... (existing contract address)">
            <div class="btn-group">
                <button class="btn secondary" id="use-existing-btn">Use Existing</button>
                <button class="btn" id="deploy-new-btn">Deploy New</button>
            </div>
        </div>
    </div>

    <!-- ÌÖçÏä§Ìä∏ ÏûÖÎ†• -->
    <div id="text-input-overlay">
        <input type="text" id="text-input" placeholder="Type here...">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script>
        // ===== ÏÑ§Ï†ï =====
        const CONFIG = {
            // Î°úÏª¨ ÌÖåÏä§Ìä∏Ïö© (Anvil)
            chainId: 31337,
            chainName: 'Anvil Local',
            rpcUrl: 'http://localhost:8545',
            // Ïã§Ï†ú Î∞∞Ìè¨Ïãú:
            // chainId: 85300,
            // chainName: 'CipherBFT L1',
            // rpcUrl: 'https://rpc.cipherbft.xyz/',

            updateInterval: 50,

            colors: [
                '#000000', '#ffffff', '#ff0000', '#ff9900',
                '#ffff00', '#00ff00', '#00ffff', '#0000ff',
                '#9900ff', '#ff00ff', '#795548', '#607d8b',
                '#e91e63', '#00bcd4', '#8bc34a', '#ff5722'
            ]
        };

        const CONTRACT_ABI = [
            "function join(string nickname) external",
            "function startStroke(uint16 x, uint16 y, uint8 color, uint8 brushSize) external returns (uint256)",
            "function moveStroke(uint256 strokeId, uint16 x, uint16 y) external",
            "function moveStrokeBatch(uint256 strokeId, uint16[] points) external",
            "function endStroke(uint256 strokeId) external",
            "function drawCompleteStroke(uint16[] points, uint8 color, uint8 brushSize) external returns (uint256)",
            "function clearCanvas() external",
            "function leave() external",
            "function getActiveUsers() view returns (address[])",
            "function getUserInfo(address user) view returns (string nickname, bool isActive, uint256 strokeCount)",
            "function totalStrokes() view returns (uint256)",
            "function canvasVersion() view returns (uint256)",
            "event StrokeStart(address indexed user, uint256 indexed strokeId, uint16 x, uint16 y, uint8 color, uint8 brushSize)",
            "event StrokeMove(address indexed user, uint256 indexed strokeId, uint16 x, uint16 y)",
            "event StrokeEnd(address indexed user, uint256 indexed strokeId)",
            "event CanvasCleared(address indexed user)",
            "event UserJoined(address indexed user, string nickname)",
            "event UserLeft(address indexed user)"
        ];

        // ===== ÏÉÅÌÉú =====
        let provider = null;
        let signer = null;
        let contract = null;
        let contractAddress = null;
        let myAddress = null;
        let isJoined = false;

        // ÏÑ∏ÏÖò ÌÇ§
        let sessionWallet = null;
        let sessionContract = null;

        // Ï∫îÎ≤ÑÏä§
        let canvas, ctx;
        let isDrawing = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let brushSize = 3;
        let currentStrokeId = null;
        let strokePoints = [];
        let lastPoint = null;

        // ÎèÑÌòï Í∑∏Î¶¨Í∏∞Ïö©
        let shapeStart = null;
        let tempCanvas, tempCtx;

        // Ïª§ÏÑú
        const cursors = new Map();
        let lastCursorUpdate = { x: 0, y: 0 };

        // ÌÜµÍ≥Ñ
        let stats = { txSent: 0, strokes: 0 };

        // Ï∫îÎ≤ÑÏä§ Î≤ÑÏ†Ñ (ÌÅ¥Î¶¨Ïñ¥ Ï∂îÏ†Å)
        let currentCanvasVersion = 0;

        // ===== DOM =====
        const canvasContainer = document.getElementById('canvas-container');
        const cursorLayer = document.getElementById('cursor-layer');
        const connectBtn = document.getElementById('connect-btn');
        const deployBtn = document.getElementById('deploy-btn');
        const joinBtn = document.getElementById('join-btn');
        const connectionStatus = document.getElementById('connection-status');
        const myAddressEl = document.getElementById('my-address');
        const strokeCountEl = document.getElementById('stroke-count');
        const txSentEl = document.getElementById('tx-sent');
        const usersEl = document.getElementById('users');
        const userCountEl = document.getElementById('user-count');
        const eventLog = document.getElementById('event-log');
        const contractModal = document.getElementById('contract-modal');
        const contractInput = document.getElementById('contract-input');
        const brushSizeInput = document.getElementById('brush-size');
        const brushDot = document.getElementById('brush-dot');
        const textInputOverlay = document.getElementById('text-input-overlay');
        const textInput = document.getElementById('text-input');

        // ===== Ï¥àÍ∏∞Ìôî =====
        function init() {
            // Ï∫îÎ≤ÑÏä§ ÏÑ§Ï†ï
            canvas = document.getElementById('whiteboard');
            ctx = canvas.getContext('2d');
            resizeCanvas();

            // ÏûÑÏãú Ï∫îÎ≤ÑÏä§ (ÎèÑÌòï ÎØ∏Î¶¨Î≥¥Í∏∞Ïö©)
            tempCanvas = document.createElement('canvas');
            tempCtx = tempCanvas.getContext('2d');

            // ÏÉâÏÉÅ ÌåîÎ†àÌä∏ ÏÉùÏÑ±
            const palette = document.getElementById('color-palette');
            CONFIG.colors.forEach((color, i) => {
                const btn = document.createElement('button');
                btn.className = 'color-btn' + (i === 0 ? ' active' : '');
                btn.style.background = color;
                btn.dataset.color = color;
                btn.onclick = () => selectColor(color, btn);
                palette.appendChild(btn);
            });

            // Ìà¥ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.onclick = () => selectTool(btn.dataset.tool, btn);
            });

            // Î∏åÎü¨Ïãú ÌÅ¨Í∏∞
            brushSizeInput.oninput = () => {
                brushSize = parseInt(brushSizeInput.value);
                updateBrushPreview();
            };
            updateBrushPreview();

            // Ï∫îÎ≤ÑÏä§ Ïù¥Î≤§Ìä∏
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);

            // ÌÅ¥Î¶¨Ïñ¥ Î≤ÑÌäº
            document.getElementById('clear-btn').onclick = clearCanvas;

            // ÌÖçÏä§Ìä∏ ÏûÖÎ†•
            textInput.addEventListener('keydown', handleTextInput);
            textInput.addEventListener('blur', hideTextInput);

            // ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à
            window.addEventListener('resize', resizeCanvas);

            // Ïó∞Í≤∞ Î≤ÑÌäº
            connectBtn.addEventListener('click', connectWallet);
            deployBtn.addEventListener('click', () => contractModal.classList.add('active'));
            document.getElementById('deploy-new-btn').addEventListener('click', deployContract);
            document.getElementById('use-existing-btn').addEventListener('click', useExistingContract);
            joinBtn.addEventListener('click', joinSession);

            log('Whiteboard loaded. Connect wallet to start!');
        }

        function resizeCanvas() {
            const rect = canvasContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            tempCanvas.width = rect.width;
            tempCanvas.height = rect.height;
            // Ìù∞ÏÉâ Î∞∞Í≤Ω
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function updateBrushPreview() {
            brushDot.style.width = brushSize + 'px';
            brushDot.style.height = brushSize + 'px';
        }

        // ===== Î°úÍπÖ =====
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            eventLog.appendChild(entry);
            eventLog.scrollTop = eventLog.scrollHeight;
            while (eventLog.children.length > 50) {
                eventLog.removeChild(eventLog.firstChild);
            }
        }

        // ===== ÎèÑÍµ¨ ÏÑ†ÌÉù =====
        function selectTool(tool, btn) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            canvas.style.cursor = tool === 'eraser' ? 'cell' : 'crosshair';
        }

        function selectColor(color, btn) {
            currentColor = color;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        // ===== Í∑∏Î¶¨Í∏∞ =====
        function handleMouseDown(e) {
            if (!isJoined) return;

            const { x, y } = getCanvasPoint(e);
            isDrawing = true;
            lastPoint = { x, y };
            strokePoints = [x, y];
            shapeStart = { x, y };

            if (currentTool === 'pen' || currentTool === 'eraser') {
                startStroke(x, y);
            } else if (currentTool === 'text') {
                showTextInput(e.clientX, e.clientY, x, y);
                isDrawing = false;
            }
        }

        function handleMouseMove(e) {
            const { x, y } = getCanvasPoint(e);

            // Ïª§ÏÑú ÏúÑÏπò Ï†ÑÏÜ°
            sendCursorPosition(x, y);

            if (!isDrawing) return;

            if (currentTool === 'pen' || currentTool === 'eraser') {
                drawLine(lastPoint.x, lastPoint.y, x, y);
                strokePoints.push(x, y);
                lastPoint = { x, y };
            } else if (['rect', 'circle', 'arrow'].includes(currentTool)) {
                // ÏûÑÏãú Ï∫îÎ≤ÑÏä§Ïóê ÎØ∏Î¶¨Î≥¥Í∏∞
                drawShapePreview(x, y);
            }
        }

        function handleMouseUp(e) {
            if (!isDrawing) return;
            isDrawing = false;

            if (currentTool === 'pen' || currentTool === 'eraser') {
                endStroke();
            } else if (['rect', 'circle', 'arrow'].includes(currentTool) && shapeStart) {
                const { x, y } = getCanvasPoint(e);
                drawShape(shapeStart.x, shapeStart.y, x, y);
                shapeStart = null;
            }
        }

        function getCanvasPoint(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function drawLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = currentTool === 'eraser' ? '#ffffff' : currentColor;
            ctx.lineWidth = currentTool === 'eraser' ? brushSize * 3 : brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        function drawShapePreview(x, y) {
            // ÏûÑÏãú Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶¨Ïñ¥ ÌõÑ Î©îÏù∏ Ï∫îÎ≤ÑÏä§ Î≥µÏÇ¨
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.drawImage(canvas, 0, 0);

            tempCtx.strokeStyle = currentColor;
            tempCtx.lineWidth = brushSize;
            tempCtx.beginPath();

            if (currentTool === 'rect') {
                tempCtx.strokeRect(shapeStart.x, shapeStart.y, x - shapeStart.x, y - shapeStart.y);
            } else if (currentTool === 'circle') {
                const rx = Math.abs(x - shapeStart.x) / 2;
                const ry = Math.abs(y - shapeStart.y) / 2;
                const cx = shapeStart.x + (x - shapeStart.x) / 2;
                const cy = shapeStart.y + (y - shapeStart.y) / 2;
                tempCtx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                tempCtx.stroke();
            } else if (currentTool === 'arrow') {
                drawArrow(tempCtx, shapeStart.x, shapeStart.y, x, y);
            }

            // Î©îÏù∏ Ï∫îÎ≤ÑÏä§Ïóê ÏûÑÏãú Ï∫îÎ≤ÑÏä§ ÌëúÏãú
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);
        }

        function drawShape(x1, y1, x2, y2) {
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = brushSize;
            ctx.beginPath();

            if (currentTool === 'rect') {
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                // Ìè¨Ïù∏Ìä∏ Ï†ÄÏû•
                strokePoints = [x1, y1, x2, y1, x2, y2, x1, y2, x1, y1];
            } else if (currentTool === 'circle') {
                const rx = Math.abs(x2 - x1) / 2;
                const ry = Math.abs(y2 - y1) / 2;
                const cx = x1 + (x2 - x1) / 2;
                const cy = y1 + (y2 - y1) / 2;
                ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                ctx.stroke();
                // ÏõêÏùÄ Ïó¨Îü¨ Ï†êÏúºÎ°ú Í∑ºÏÇ¨
                strokePoints = [];
                for (let i = 0; i <= 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    strokePoints.push(Math.round(cx + rx * Math.cos(angle)));
                    strokePoints.push(Math.round(cy + ry * Math.sin(angle)));
                }
            } else if (currentTool === 'arrow') {
                drawArrow(ctx, x1, y1, x2, y2);
                strokePoints = [x1, y1, x2, y2];
            }

            // Ïò®Ï≤¥Ïù∏ Ï†ÑÏÜ°
            sendCompleteStroke();
        }

        function drawArrow(context, x1, y1, x2, y2) {
            const headLen = 15;
            const angle = Math.atan2(y2 - y1, x2 - x1);

            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
            context.moveTo(x2, y2);
            context.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
            context.stroke();
        }

        // ÌÖçÏä§Ìä∏ ÎèÑÍµ¨
        function showTextInput(clientX, clientY, canvasX, canvasY) {
            textInputOverlay.style.left = clientX + 'px';
            textInputOverlay.style.top = clientY + 'px';
            textInputOverlay.classList.add('active');
            textInputOverlay.dataset.canvasX = canvasX;
            textInputOverlay.dataset.canvasY = canvasY;
            textInput.value = '';
            textInput.focus();
        }

        function hideTextInput() {
            textInputOverlay.classList.remove('active');
        }

        function handleTextInput(e) {
            if (e.key === 'Enter') {
                const text = textInput.value;
                const x = parseInt(textInputOverlay.dataset.canvasX);
                const y = parseInt(textInputOverlay.dataset.canvasY);

                if (text) {
                    ctx.font = `${brushSize * 5}px sans-serif`;
                    ctx.fillStyle = currentColor;
                    ctx.fillText(text, x, y);

                    // ÌÖçÏä§Ìä∏Îäî ÏãúÏûëÏ†êÎßå Ï†ÑÏÜ° (Í∞ÑÎã®Ìôî)
                    strokePoints = [x, y, x + 1, y + 1];
                    sendCompleteStroke();
                }

                hideTextInput();
            } else if (e.key === 'Escape') {
                hideTextInput();
            }
        }

        // ===== Ïò®Ï≤¥Ïù∏ Ìï®Ïàò =====
        async function startStroke(x, y) {
            if (!sessionContract) return;

            try {
                const colorIndex = CONFIG.colors.indexOf(currentColor);
                const color = colorIndex >= 0 ? colorIndex : 0;
                const size = currentTool === 'eraser' ? 15 : brushSize; // ÏßÄÏö∞Í∞úÎäî Ìù∞ÏÉâ, ÌÅ∞ Î∏åÎü¨Ïãú

                const tx = await sessionContract.startStroke(
                    Math.round(x), Math.round(y),
                    currentTool === 'eraser' ? 1 : color, // 1 = white
                    size,
                    { gasLimit: 150000 }
                );

                const receipt = await tx.wait();
                // strokeId Ï∂îÏ∂ú
                const event = receipt.events?.find(e => e.event === 'StrokeStart');
                if (event) {
                    currentStrokeId = event.args.strokeId.toNumber();
                }

                stats.txSent++;
                updateStats();
            } catch (error) {
                log(`Stroke start error: ${error.message}`, 'error');
            }
        }

        async function endStroke() {
            if (!sessionContract || currentStrokeId === null) return;

            try {
                // Î∞∞ÏπòÎ°ú Ï§ëÍ∞Ñ Ï†êÎì§ Ï†ÑÏÜ°
                if (strokePoints.length > 4) {
                    const points = strokePoints.slice(2).map(p => Math.round(p)); // ÏãúÏûëÏ†ê Ï†úÏô∏
                    if (points.length >= 2) {
                        await sessionContract.moveStrokeBatch(currentStrokeId, points, { gasLimit: 500000 });
                        stats.txSent++;
                    }
                }

                await sessionContract.endStroke(currentStrokeId, { gasLimit: 100000 });
                stats.txSent++;
                stats.strokes++;
                updateStats();

                currentStrokeId = null;
                strokePoints = [];
            } catch (error) {
                log(`Stroke end error: ${error.message}`, 'error');
            }
        }

        async function sendCompleteStroke() {
            if (!sessionContract || strokePoints.length < 4) return;

            try {
                const colorIndex = CONFIG.colors.indexOf(currentColor);
                const color = colorIndex >= 0 ? colorIndex : 0;
                const points = strokePoints.map(p => Math.round(p));

                await sessionContract.drawCompleteStroke(points, color, brushSize, { gasLimit: 500000 });
                stats.txSent++;
                stats.strokes++;
                updateStats();

                strokePoints = [];
            } catch (error) {
                log(`Complete stroke error: ${error.message}`, 'error');
            }
        }

        async function clearCanvas() {
            if (!sessionContract) {
                // Î°úÏª¨Îßå ÌÅ¥Î¶¨Ïñ¥
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }

            try {
                await sessionContract.clearCanvas({ gasLimit: 100000 });
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                stats.txSent++;
                updateStats();
                log('Canvas cleared', 'tx');
            } catch (error) {
                log(`Clear error: ${error.message}`, 'error');
            }
        }

        function sendCursorPosition(x, y) {
            // ÎÑàÎ¨¥ ÏûêÏ£º Î≥¥ÎÇ¥ÏßÄ ÏïäÎèÑÎ°ù throttle
            if (Math.abs(x - lastCursorUpdate.x) < 5 && Math.abs(y - lastCursorUpdate.y) < 5) return;
            lastCursorUpdate = { x, y };

            // Ïª§ÏÑú ÏúÑÏπòÎäî Ïù¥Î≤§Ìä∏Î°úÎßå (Î≥ÑÎèÑ Ïª®Ìä∏ÎûôÌä∏ ÏóÜÏù¥ Î°úÏª¨ ÌëúÏãú)
            // Ïã§Ï†úÎ°úÎäî MouseTrackerÏ≤òÎüº Î≥ÑÎèÑ Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö© Í∞ÄÎä•
        }

        function updateStats() {
            txSentEl.textContent = stats.txSent;
            strokeCountEl.textContent = stats.strokes;
        }

        // ===== Ïª§ÏÑú Í¥ÄÎ¶¨ =====
        function getColorForAddress(address) {
            const index = parseInt(address.slice(-4), 16) % CONFIG.colors.length;
            return CONFIG.colors[index];
        }

        function createCursor(address, nickname) {
            if (cursors.has(address.toLowerCase())) return;

            const color = getColorForAddress(address);
            const cursor = document.createElement('div');
            cursor.className = 'remote-cursor';
            cursor.style.setProperty('--cursor-color', color);
            cursor.innerHTML = `
                <div class="cursor-pointer"></div>
                <div class="cursor-label">${nickname}</div>
            `;

            cursorLayer.appendChild(cursor);
            cursors.set(address.toLowerCase(), { element: cursor, nickname, color });
            updateUserList();
        }

        function updateUserList() {
            usersEl.innerHTML = '';
            userCountEl.textContent = cursors.size;

            cursors.forEach((cursor, address) => {
                const isMe = address.toLowerCase() === myAddress?.toLowerCase();
                const item = document.createElement('div');
                item.className = 'user-item';
                item.innerHTML = `
                    <div class="user-dot" style="background: ${cursor.color}"></div>
                    <div class="user-name">${cursor.nickname}${isMe ? ' (me)' : ''}</div>
                `;
                usersEl.appendChild(item);
            });
        }

        // ===== ÏßÄÍ∞ë Ïó∞Í≤∞ =====
        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    alert('Please install MetaMask!');
                    return;
                }

                log('Connecting wallet...');
                connectBtn.disabled = true;

                // ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ÑÌôò
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: `0x${CONFIG.chainId.toString(16)}` }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: `0x${CONFIG.chainId.toString(16)}`,
                                chainName: CONFIG.chainName,
                                rpcUrls: [CONFIG.rpcUrl],
                                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 }
                            }]
                        });
                    }
                }

                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send('eth_requestAccounts', []);
                signer = provider.getSigner();
                myAddress = await signer.getAddress();

                connectionStatus.textContent = 'Connected';
                connectionStatus.classList.add('connected');
                myAddressEl.textContent = `${myAddress.slice(0, 6)}...${myAddress.slice(-4)}`;
                connectBtn.textContent = 'Connected';
                deployBtn.disabled = false;

                log(`Connected: ${myAddress.slice(0, 10)}...`, 'tx');

                // Ï†ÄÏû•Îêú Ïª®Ìä∏ÎûôÌä∏ Î≥µÏõê
                const saved = localStorage.getItem('whiteboardContract');
                if (saved) contractInput.value = saved;

            } catch (error) {
                log(`Connection error: ${error.message}`, 'error');
                connectBtn.disabled = false;
            }
        }

        async function deployContract() {
            contractModal.classList.remove('active');
            deployBtn.disabled = true;
            deployBtn.innerHTML = '<span class="spinner"></span> Deploying...';

            try {
                log('Deploying OnchainWhiteboard...');

                // Ïª¥ÌååÏùºÎêú Î∞îÏù¥Ìä∏ÏΩîÎìú (forgeÏóêÏÑú Í∞ÄÏ†∏Ïò¥)
                const bytecode = await fetch('onChainWhiteBoard/out/OnchainWhiteboard.sol/OnchainWhiteboard.json')
                    .then(r => r.json())
                    .then(j => j.bytecode.object)
                    .catch(() => null);

                if (!bytecode) {
                    // Fallback: Í∞ÑÎã®Ìïú Î∞∞Ìè¨ (Ïã§Ï†úÎ°úÎäî Î∞îÏù¥Ìä∏ÏΩîÎìú ÌïÑÏöî)
                    log('Bytecode not found. Please deploy via forge.', 'error');
                    log('Run: forge script script/Deploy.s.sol:DeployWhiteboard --rpc-url http://localhost:8545 --broadcast --private-key <KEY>', 'info');
                    deployBtn.textContent = 'Setup Contract';
                    deployBtn.disabled = false;
                    return;
                }

                const factory = new ethers.ContractFactory(CONTRACT_ABI, bytecode, signer);
                const contractInstance = await factory.deploy();
                await contractInstance.deployed();

                contractAddress = contractInstance.address;
                contract = new ethers.Contract(contractAddress, CONTRACT_ABI, signer);

                localStorage.setItem('whiteboardContract', contractAddress);

                log(`Deployed: ${contractAddress}`, 'tx');
                deployBtn.textContent = 'Contract Ready';
                joinBtn.disabled = false;

            } catch (error) {
                log(`Deploy error: ${error.message}`, 'error');
                deployBtn.textContent = 'Setup Contract';
                deployBtn.disabled = false;
            }
        }

        async function useExistingContract() {
            const address = contractInput.value.trim();
            if (!address || !ethers.utils.isAddress(address)) {
                alert('Enter valid contract address!');
                return;
            }

            contractAddress = address;
            contract = new ethers.Contract(contractAddress, CONTRACT_ABI, signer);

            try {
                const version = await contract.canvasVersion();
                log(`Connected to contract (version ${version})`, 'tx');
                localStorage.setItem('whiteboardContract', contractAddress);

                contractModal.classList.remove('active');
                deployBtn.textContent = 'Contract Ready';
                joinBtn.disabled = false;

            } catch (error) {
                log(`Invalid contract: ${error.message}`, 'error');
            }
        }

        async function joinSession() {
            try {
                joinBtn.disabled = true;
                joinBtn.innerHTML = '<span class="spinner"></span> Setting up...';

                // ÏÑ∏ÏÖò ÏõîÎ†õ ÏÉùÏÑ±
                sessionWallet = ethers.Wallet.createRandom().connect(provider);
                log(`Session: ${sessionWallet.address.slice(0, 10)}...`);

                // ÌéÄÎî©
                log('Funding session wallet...');
                const fundTx = await signer.sendTransaction({
                    to: sessionWallet.address,
                    value: ethers.utils.parseEther('0.5')
                });
                await fundTx.wait();
                log('Funded!', 'tx');

                // ÏÑ∏ÏÖò Ïª®Ìä∏ÎûôÌä∏
                sessionContract = new ethers.Contract(contractAddress, CONTRACT_ABI, sessionWallet);

                // Join
                const nickname = `Artist_${sessionWallet.address.slice(-4)}`;
                myAddress = sessionWallet.address;

                const tx = await sessionContract.join(nickname);
                await tx.wait();

                isJoined = true;
                stats.txSent++;

                myAddressEl.textContent = `${myAddress.slice(0, 6)}...${myAddress.slice(-4)}`;
                createCursor(myAddress, nickname);

                // Ïù¥Î≤§Ìä∏ Ìè¥ÎßÅ ÏãúÏûë
                startEventPolling();

                joinBtn.textContent = 'Joined!';
                log('Joined! Start drawing.', 'tx');

            } catch (error) {
                log(`Join error: ${error.message}`, 'error');
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join Room';
            }
        }

        // ===== Ïù¥Î≤§Ìä∏ Ìè¥ÎßÅ =====
        function startEventPolling() {
            let lastBlock = 0;

            setInterval(async () => {
                try {
                    const currentBlock = await provider.getBlockNumber();
                    if (lastBlock === 0) lastBlock = currentBlock - 1;

                    if (currentBlock > lastBlock) {
                        // StrokeStart
                        const startEvents = await contract.queryFilter(
                            contract.filters.StrokeStart(),
                            lastBlock + 1,
                            currentBlock
                        );

                        for (const event of startEvents) {
                            const { user, strokeId, x, y, color, brushSize } = event.args;
                            if (user.toLowerCase() !== myAddress?.toLowerCase()) {
                                // Îã§Î•∏ Ïú†Ï†ÄÏùò Í∑∏Î¶¨Í∏∞ ÏãúÏûë
                                drawRemotePoint(x, y, CONFIG.colors[color] || '#000', brushSize);
                            }
                        }

                        // StrokeMove
                        const moveEvents = await contract.queryFilter(
                            contract.filters.StrokeMove(),
                            lastBlock + 1,
                            currentBlock
                        );

                        for (const event of moveEvents) {
                            const { user, strokeId, x, y } = event.args;
                            if (user.toLowerCase() !== myAddress?.toLowerCase()) {
                                // Í∞ÑÎã®Ìûà Ï†êÎßå Ï∞çÏùå (Ïã§Ï†úÎ°úÎäî strokeIdÎ°ú Ïó∞Í≤∞Ìï¥Ïïº Ìï®)
                                drawRemotePoint(x, y, getColorForAddress(user), 3);
                            }
                        }

                        // CanvasCleared
                        const clearEvents = await contract.queryFilter(
                            contract.filters.CanvasCleared(),
                            lastBlock + 1,
                            currentBlock
                        );

                        if (clearEvents.length > 0) {
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            log('Canvas cleared by another user', 'event');
                        }

                        // UserJoined
                        const joinEvents = await contract.queryFilter(
                            contract.filters.UserJoined(),
                            lastBlock + 1,
                            currentBlock
                        );

                        for (const event of joinEvents) {
                            const { user, nickname } = event.args;
                            if (user.toLowerCase() !== myAddress?.toLowerCase()) {
                                createCursor(user, nickname);
                                log(`${nickname} joined`, 'event');
                            }
                        }

                        lastBlock = currentBlock;
                    }
                } catch (error) {
                    // Î¨¥Ïãú
                }
            }, 300);
        }

        function drawRemotePoint(x, y, color, size) {
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }

        // ===== ÏãúÏûë =====
        init();
    </script>
</body>
</html>
