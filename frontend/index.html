<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üñ±Ô∏è CipherBFT Onchain Mouse Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* Ïª§ÏÑú Ïä§ÌÉÄÏùº */
        .cursor {
            position: absolute;
            pointer-events: none;
            transition: all 0.05s linear;
            z-index: 100;
        }
        
        .cursor-pointer {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 16px solid var(--cursor-color, #00ff88);
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 4px var(--cursor-color, #00ff88));
        }
        
        .cursor-label {
            position: absolute;
            left: 16px;
            top: 10px;
            background: var(--cursor-color, #00ff88);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
        }
        
        /* ÏÉÅÌÉú Ìå®ÎÑê */
        #status-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 280px;
            z-index: 1000;
        }
        
        #status-panel h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #00ff88;
        }
        
        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .status-label {
            color: #888;
        }
        
        .status-value {
            color: #fff;
            font-family: monospace;
        }
        
        .status-value.connected {
            color: #00ff88;
        }
        
        .status-value.disconnected {
            color: #ff4444;
        }
        
        /* TX Ïπ¥Ïö¥ÌÑ∞ */
        #tx-counter {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tx-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        /* Ïú†Ï†Ä Î¶¨Ïä§Ìä∏ */
        #user-list {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        #user-list h2 {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }
        
        .user-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
        }
        
        .user-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        /* Ïó∞Í≤∞ Î≤ÑÌäº */
        #connect-btn {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 1000;
        }
        
        #connect-btn:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }
        
        #connect-btn:disabled {
            background: #444;
            cursor: not-allowed;
        }
        
        /* Î°úÍ∑∏ */
        #event-log {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 350px;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            z-index: 1000;
        }
        
        .log-entry {
            color: #888;
            margin-bottom: 3px;
        }
        
        .log-entry.tx {
            color: #00ff88;
        }
        
        .log-entry.event {
            color: #88ccff;
        }
        
        .log-entry.error {
            color: #ff4444;
        }
        
        /* Í∑∏Î¶¨Îìú Î∞∞Í≤Ω */
        #grid-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="grid-bg"></div>
    <div id="canvas-container"></div>
    
    <!-- ÏÉÅÌÉú Ìå®ÎÑê -->
    <div id="status-panel">
        <h1>üñ±Ô∏è Onchain Mouse Tracker</h1>
        <div class="status-row">
            <span class="status-label">Network</span>
            <span class="status-value">CipherBFT L1</span>
        </div>
        <div class="status-row">
            <span class="status-label">Status</span>
            <span class="status-value disconnected" id="connection-status">Disconnected</span>
        </div>
        <div class="status-row">
            <span class="status-label">Block Time</span>
            <span class="status-value">~10ms</span>
        </div>
        <div class="status-row">
            <span class="status-label">My Position</span>
            <span class="status-value" id="my-position">-</span>
        </div>
        
        <div id="tx-counter">
            <div class="tx-stat">
                <span class="status-label">TX Sent</span>
                <span class="status-value" id="tx-sent">0</span>
            </div>
            <div class="tx-stat">
                <span class="status-label">Events Received</span>
                <span class="status-value" id="events-received">0</span>
            </div>
            <div class="tx-stat">
                <span class="status-label">Avg Latency</span>
                <span class="status-value" id="avg-latency">-</span>
            </div>
        </div>
    </div>
    
    <!-- Ïú†Ï†Ä Î¶¨Ïä§Ìä∏ -->
    <div id="user-list">
        <h2>üë• Active Users</h2>
        <div id="users"></div>
    </div>
    
    <!-- Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ -->
    <div id="event-log">
        <div class="log-entry">Waiting for connection...</div>
    </div>
    
    <!-- Ïó∞Í≤∞ Î≤ÑÌäº -->
    <button id="connect-btn">üîó Connect Wallet & Join</button>

    <!-- ethers.js CDN -->
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    
    <script>
        // ===== ÏÑ§Ï†ï =====
        const CONFIG = {
            // Custom L1 Network
            chainId: 85300,
            chainName: 'CipherBFT L1',
            rpcUrl: 'https://jsonrpc.cipherbft.xyz/',
            wsUrl: 'wss://jsonrpc.cipherbft.xyz/', // WebSocket for subscriptions (ÌôïÏù∏ ÌïÑÏöî)
            blockExplorer: '', // TODO: Î∏îÎ°ù ÏùµÏä§ÌîåÎ°úÎü¨ URL
            
            // Î∞∞Ìè¨Îêú Ïª®Ìä∏ÎûôÌä∏ Ï£ºÏÜå (TODO: Ïã§Ï†ú Î∞∞Ìè¨ ÌõÑ ÍµêÏ≤¥)
            contractAddress: '0x0000000000000000000000000000000000000000',
            
            // ÎßàÏö∞Ïä§ Ïù¥Îèô ÏóÖÎç∞Ïù¥Ìä∏ Í∞ÑÍ≤© (ms)
            updateInterval: 50, // 50msÎßàÎã§ TX Ï†ÑÏÜ°
            
            // ÏÉâÏÉÅ ÌåîÎ†àÌä∏
            colors: [
                '#00ff88', '#ff6b6b', '#4ecdc4', '#ffe66d', 
                '#95e1d3', '#f38181', '#aa96da', '#fcbad3',
                '#a8d8ea', '#ff9a3c', '#155263', '#c9b1ff'
            ]
        };
        
        // Ïª®Ìä∏ÎûôÌä∏ ABI (ÌïÑÏöîÌïú Ìï®ÏàòÎßå)
        const CONTRACT_ABI = [
            "function join(string nickname) external",
            "function moveCursor(uint16 x, uint16 y) external",
            "function leave() external",
            "function getActiveUsers() view returns (address[])",
            "function getUserInfo(address user) view returns (string nickname, uint16 x, uint16 y, bool isActive)",
            "event CursorMoved(address indexed user, uint16 x, uint16 y, uint256 timestamp)",
            "event UserJoined(address indexed user, string nickname)",
            "event UserLeft(address indexed user)"
        ];
        
        // ===== ÏÉÅÌÉú =====
        let provider = null;
        let signer = null;
        let contract = null;
        let wsProvider = null;
        let myAddress = null;
        let isJoined = false;
        
        // Ïª§ÏÑú ÏÉÅÌÉú
        const cursors = new Map(); // address -> {element, nickname, color}
        let lastSentPosition = { x: 0, y: 0 };
        let pendingPosition = null;
        let updateTimer = null;
        
        // ÌÜµÍ≥Ñ
        let stats = {
            txSent: 0,
            eventsReceived: 0,
            latencies: []
        };
        
        // ===== DOM ÏöîÏÜå =====
        const canvasContainer = document.getElementById('canvas-container');
        const connectBtn = document.getElementById('connect-btn');
        const connectionStatus = document.getElementById('connection-status');
        const myPositionEl = document.getElementById('my-position');
        const txSentEl = document.getElementById('tx-sent');
        const eventsReceivedEl = document.getElementById('events-received');
        const avgLatencyEl = document.getElementById('avg-latency');
        const usersEl = document.getElementById('users');
        const eventLog = document.getElementById('event-log');
        
        // ===== Î°úÍπÖ =====
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            eventLog.appendChild(entry);
            eventLog.scrollTop = eventLog.scrollHeight;
            
            // ÏµúÎåÄ 50Í∞ú Î°úÍ∑∏ Ïú†ÏßÄ
            while (eventLog.children.length > 50) {
                eventLog.removeChild(eventLog.firstChild);
            }
        }
        
        // ===== Ïª§ÏÑú Í¥ÄÎ¶¨ =====
        function getColorForAddress(address) {
            const index = parseInt(address.slice(-4), 16) % CONFIG.colors.length;
            return CONFIG.colors[index];
        }
        
        function createCursor(address, nickname) {
            if (cursors.has(address)) return;
            
            const color = getColorForAddress(address);
            
            const cursor = document.createElement('div');
            cursor.className = 'cursor';
            cursor.style.setProperty('--cursor-color', color);
            cursor.innerHTML = `
                <div class="cursor-pointer"></div>
                <div class="cursor-label">${nickname}</div>
            `;
            
            canvasContainer.appendChild(cursor);
            cursors.set(address, { element: cursor, nickname, color });
            
            updateUserList();
        }
        
        function updateCursor(address, x, y) {
            const cursor = cursors.get(address);
            if (!cursor) return;
            
            // ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò (0-65535 -> ÌôîÎ©¥ ÌÅ¨Í∏∞)
            const screenX = (x / 65535) * window.innerWidth;
            const screenY = (y / 65535) * window.innerHeight;
            
            cursor.element.style.left = `${screenX}px`;
            cursor.element.style.top = `${screenY}px`;
        }
        
        function removeCursor(address) {
            const cursor = cursors.get(address);
            if (cursor) {
                cursor.element.remove();
                cursors.delete(address);
                updateUserList();
            }
        }
        
        function updateUserList() {
            usersEl.innerHTML = '';
            cursors.forEach((cursor, address) => {
                const item = document.createElement('div');
                item.className = 'user-item';
                item.innerHTML = `
                    <div class="user-dot" style="background: ${cursor.color}"></div>
                    <span>${cursor.nickname} ${address === myAddress ? '(me)' : ''}</span>
                `;
                usersEl.appendChild(item);
            });
        }
        
        // ===== ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ =====
        function updateStats() {
            txSentEl.textContent = stats.txSent;
            eventsReceivedEl.textContent = stats.eventsReceived;
            
            if (stats.latencies.length > 0) {
                const avg = stats.latencies.slice(-20).reduce((a, b) => a + b, 0) / Math.min(stats.latencies.length, 20);
                avgLatencyEl.textContent = `${avg.toFixed(1)}ms`;
            }
        }
        
        // ===== ÏßÄÍ∞ë Ïó∞Í≤∞ =====
        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    alert('MetaMaskÎ•º ÏÑ§ÏπòÌï¥Ï£ºÏÑ∏Ïöî!');
                    return;
                }
                
                log('Connecting wallet...');
                connectBtn.disabled = true;
                connectBtn.textContent = '‚è≥ Connecting...';
                
                // ÎÑ§Ìä∏ÏõåÌÅ¨ ÌôïÏù∏/Ï∂îÍ∞Ä
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: `0x${CONFIG.chainId.toString(16)}` }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: `0x${CONFIG.chainId.toString(16)}`,
                                chainName: CONFIG.chainName,
                                rpcUrls: [CONFIG.rpcUrl],
                                blockExplorerUrls: [CONFIG.blockExplorer]
                            }]
                        });
                    }
                }
                
                // Ïó∞Í≤∞
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send('eth_requestAccounts', []);
                signer = provider.getSigner();
                myAddress = await signer.getAddress();
                
                log(`Connected: ${myAddress.slice(0, 6)}...${myAddress.slice(-4)}`, 'tx');
                
                // Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
                contract = new ethers.Contract(CONFIG.contractAddress, CONTRACT_ABI, signer);
                
                // WebSocket Ïó∞Í≤∞ (Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖÏö©)
                await setupEventSubscription();
                
                // ÏÑ∏ÏÖò Ï∞∏Í∞Ä
                await joinSession();
                
                connectionStatus.textContent = 'Connected';
                connectionStatus.className = 'status-value connected';
                connectBtn.textContent = '‚úÖ Connected';
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                connectBtn.disabled = false;
                connectBtn.textContent = 'üîó Connect Wallet & Join';
            }
        }
        
        // ===== Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ =====
        async function setupEventSubscription() {
            log('Setting up event subscription...', 'event');
            
            // WebSocket providerÎ°ú Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ
            // WebSocketÏúºÎ°ú Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ
            wsProvider = new ethers.providers.WebSocketProvider(CONFIG.wsUrl);
            const wsContract = new ethers.Contract(CONFIG.contractAddress, CONTRACT_ABI, wsProvider);
            
            // CursorMoved Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ
            wsContract.on('CursorMoved', (user, x, y, timestamp, event) => {
                stats.eventsReceived++;
                
                // ÏßÄÏó∞ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (ÏûêÏã†Ïùò TXÏù∏ Í≤ΩÏö∞)
                if (user.toLowerCase() === myAddress?.toLowerCase()) {
                    const latency = Date.now() - Number(timestamp) * 1000;
                    if (latency > 0 && latency < 5000) {
                        stats.latencies.push(latency);
                    }
                }
                
                updateCursor(user, x, y);
                updateStats();
            });
            
            // UserJoined Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ
            wsContract.on('UserJoined', (user, nickname) => {
                log(`User joined: ${nickname}`, 'event');
                createCursor(user, nickname);
            });
            
            // UserLeft Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ
            wsContract.on('UserLeft', (user) => {
                log(`User left: ${user.slice(0, 8)}...`, 'event');
                removeCursor(user);
            });
            
            log('Event subscription active!', 'event');
        }
        
        // ===== ÏÑ∏ÏÖò Ï∞∏Í∞Ä =====
        async function joinSession() {
            const nickname = `User_${myAddress.slice(-4)}`;
            
            log(`Joining as ${nickname}...`, 'tx');
            
            // realtime_sendRawTransaction ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÏßÄÎßå
            // ethers.jsÎäî Í∏∞Î≥∏Ï†ÅÏúºÎ°ú eth_sendRawTransaction ÏÇ¨Ïö©
            const tx = await contract.join(nickname);
            await tx.wait();
            
            isJoined = true;
            stats.txSent++;
            
            createCursor(myAddress, nickname);
            log(`Joined successfully!`, 'tx');
            
            // Í∏∞Ï°¥ Ïú†Ï†ÄÎì§ Î°úÎìú
            await loadExistingUsers();
            
            // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ ÏãúÏûë
            startMouseTracking();
            
            updateStats();
        }
        
        // ===== Í∏∞Ï°¥ Ïú†Ï†Ä Î°úÎìú =====
        async function loadExistingUsers() {
            try {
                const users = await contract.getActiveUsers();
                for (const user of users) {
                    if (user.toLowerCase() !== myAddress.toLowerCase()) {
                        const info = await contract.getUserInfo(user);
                        if (info.isActive) {
                            createCursor(user, info.nickname);
                            updateCursor(user, info.x, info.y);
                        }
                    }
                }
            } catch (error) {
                log(`Error loading users: ${error.message}`, 'error');
            }
        }
        
        // ===== ÎßàÏö∞Ïä§ Ìä∏ÎûòÌÇπ =====
        function startMouseTracking() {
            document.addEventListener('mousemove', (e) => {
                // ÌôîÎ©¥ Ï¢åÌëúÎ•º 0-65535Î°ú Î≥ÄÌôò
                const x = Math.floor((e.clientX / window.innerWidth) * 65535);
                const y = Math.floor((e.clientY / window.innerHeight) * 65535);
                
                pendingPosition = { x, y };
                myPositionEl.textContent = `${e.clientX}, ${e.clientY}`;
                
                // ÏûêÏã†Ïùò Ïª§ÏÑúÎäî Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Î°úÏª¨)
                updateCursor(myAddress, x, y);
            });
            
            // ÏùºÏ†ï Í∞ÑÍ≤©ÏúºÎ°ú TX Ï†ÑÏÜ°
            updateTimer = setInterval(sendPositionUpdate, CONFIG.updateInterval);
        }
        
        async function sendPositionUpdate() {
            if (!isJoined || !pendingPosition) return;
            if (pendingPosition.x === lastSentPosition.x && pendingPosition.y === lastSentPosition.y) return;
            
            const { x, y } = pendingPosition;
            lastSentPosition = { x, y };
            
            try {
                // ÎÖºÎ∏îÎ°úÌÇπÏúºÎ°ú TX Ï†ÑÏÜ° (await ÏóÜÏù¥)
                contract.moveCursor(x, y).then(tx => {
                    stats.txSent++;
                    updateStats();
                }).catch(err => {
                    // ÏóêÎü¨ Î¨¥Ïãú (ÎπàÎ≤àÌïú ÏóÖÎç∞Ïù¥Ìä∏ÏóêÏÑú ÏùºÎ∂Ä Ïã§Ìå® Í∞ÄÎä•)
                });
            } catch (error) {
                // Î¨¥Ïãú
            }
        }
        
        // ===== Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà =====
        connectBtn.addEventListener('click', connectWallet);
        
        // ÌéòÏù¥ÏßÄ ÎÇòÍ∞à Îïå Ï†ïÎ¶¨
        window.addEventListener('beforeunload', async () => {
            if (isJoined && contract) {
                try {
                    await contract.leave();
                } catch (e) {}
            }
            if (wsProvider) {
                wsProvider.destroy();
            }
        });
        
        // ===== Ï¥àÍ∏∞Ìôî =====
        log('CipherBFT Onchain Mouse Tracker loaded');
        log('Click "Connect Wallet" to start');
    </script>
</body>
</html>
